local l_data = require "main.leveldata"
local l_board = require "main.leaderboard"
local node = require "main.gui-nodes"

local function deep_copy(orig) --outside/unoriginal method
	local copy = {}
	for k, v in pairs(orig) do
		if type(v) == "table" then
			copy[k] = deep_copy(v)  -- Recursively copy nested tables
		else
			copy[k] = v  -- Copy primitive values
		end
	end
	return copy
end

local function hide_floppy(self)
	gui.set(node.get.set_check, "color.w", 0)
end

local function hide_x(self)
	gui.set(gui.get_node("cancel-x"), "color.w", 0)
end

local function hash_is_num(action_hash)
	for i = 0,9 do
		if action_hash == hash(""..i) then
			return true
		end
	end
	return false
end

local function hash_to_num(action_hash)
	for i = 0,9 do
		if action_hash == hash(""..i) then
			return i
		end
	end
	return nil
end

local function shuffle(tbl)
	for i = #tbl, 2, -1 do
		local j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end

local function round(num)
	local fin_num = math.floor(num)
	if num - math.floor(num) >= 0.5 then
		fin_num = fin_num + 1
	end
	return fin_num
end

local function get_firework_color(id)
	-- 									-#1-													-#2-												-#3-												-#4-												-#5-												-#6-												-#7-													-#8-												-#9-												-#10-
	local colors = {(vmath.vector4((172/255), (50/255), (50/255), 1)), (vmath.vector4((251/255), (242/255), (54/255), 1)), (vmath.vector4((99/255), (155/255), (255/255), 1)), (vmath.vector4((95/255), (205/255), (228/255), 1)), (vmath.vector4((153/255), (229/255), (80/255), 1)), (vmath.vector4((223/255), (113/255), (38/255), 1)), (vmath.vector4((215/255), (123/255), (186/255), 1)), (vmath.vector4((217/255), (87/255), (99/255), 1)), (vmath.vector4((234/255), (167/255), (0/255), 1)), (vmath.vector4((203/255), (219/255), (252/255), 1))}
	return colors[id]
end

local function midnight_switch_on(self)
	gui.play_flipbook(gui.get_node("lightbulb"), "lightbulb-lit")
	self.theme = "midnight"
	msg.post("/zoom#minefinder", "set_theme", {theme = "midnight"})
	if l_data.gui_anims then
		self.graffiti_timer = 0.1
		sprite.play_flipbook("/light-switch", "midnight-switch")
	else
		sprite.play_flipbook("/light-switch", "midnight-switch-09")
	end
end

local function midnight_switch_off(self)
	gui.set_color(gui.get_node("lightbulb-click"), vmath.vector4((203/255), (219/255), (252/255), 1))
	gui.play_flipbook(gui.get_node("lightbulb"), "lightbulb")
	self.theme = "dark"
	msg.post("/zoom#minefinder", "set_theme", {theme = "dark"})
	msg.post("/graffiti#graffiti", "disable")
	if l_data.gui_anims then
		sprite.play_flipbook("/light-switch", "midnight-switch-reverse")
	else
		sprite.play_flipbook("/light-switch", "midnight-switch-00")
	end
end


local function set_stars_pos(self, override)
	if self.text_box == 3 or override then
		if gui.get(node.get.boxes[3], "size.x") < 23 then
			gui.set(node.get.stars, "position.x", 1194+gui.get(node.get.boxes[3], "size.x")*6)
			if gui.get(node.get.stars, "position.y") ~= 288 then
				gui.set(node.get.stars, "position.y", 288)
			end
		else
			gui.set(node.get.stars, "position", vmath.vector3(1290, 234, 0))
		end
	end
end

local function calc_mine_ct(self)
	local tile_ct = l_data.size_nums[1][6]*l_data.size_nums[2][6]
	local mine_calc = 0
	if tile_ct < 64 then
		mine_calc = 18.40793+(-0.1106306-18.40793)/(1+(tile_ct/53.2421)^(1.197356))
	elseif tile_ct < 480 then
		mine_calc = 21354990+(6.525829-21354990)/(1+(tile_ct/1006912)^(1.61443))
	else
		mine_calc = 75-0.08333333*tile_ct+0.0002777778*tile_ct^(2)
	end
	mine_calc = round(mine_calc)
	return mine_calc
end

local function zoom_in(self)
	msg.post("/sfx#sfx", "key-snap")
	
	msg.post("/anims#anims", "disable")
	msg.post(".", "disable")
	msg.post("/gui-zoom#zoom", "enable")
	msg.post("/gui-zoom#zoom", "set_props", {flags = self.flag_count, mines = self.mine_count, highscore = l_data.highscore[l_data.diff], diff = l_data.diff})
	msg.post("/gui-zoom#zoom", "set_flags", {num = self.flag_count})
	msg.post("/gui#door", "zoom", {zoom = true})
	msg.post("/zoom#minefinder", "zoom", {zoom = true})
end

local function retry_but_on(self, action, action_id)
	if action.pressed and (action_id == hash("touch") or action_id == hash("retry")) then
		gui.set(node.get.retry, "position.y", -3)
		msg.post("/sfx#sfx", "button1-depress")
	elseif action.released and (action_id == hash("touch") or action_id == hash("retry")) and gui.get(node.get.retry, "position.y") == -3 then
		msg.post("/sfx#sfx", "button1-release")
		gui.set(node.get.retry, "position.y", 3)
		msg.post("/zoom#minefinder", "reset")
	elseif gui.get_color(node.get.retry_lit) == vmath.vector4((63/255), (63/255), (116/255), 1) and action_id ~= hash("retry") then
		msg.post("/zoom#minefinder", "hide_select", {hid = true})
		gui.set_color(node.get.retry_lit, vmath.vector4((203/255), (219/255), (252/255), 1))
	end
end

local function retry_but_off(self, action, action_id)
	gui.set_color(node.get.retry_lit, vmath.vector4((63/255), (63/255), (116/255), 1))
	msg.post("/zoom#minefinder", "hide_select", {hid = false})
	gui.set(node.get.retry, "position.y", 3)
end

local function deselect_txt(self)
	local orig_rows = l_data.size_nums[1][6]
	local orig_cols = l_data.size_nums[2][6]
	local orig_mines = l_data.mine_nums[6]
	local force_reset = false
	
	gui.set_color(self.outlines[self.text_box], vmath.vector4((34/255), (32/255), (52/255), 1))
	gui.set_color(node.get.text[self.text_box], vmath.vector4(1, 1, 1, 1))

	if gui.get_text(node.get.text[self.text_box]) == "" then
		if self.text_box < 3 then
			gui.set_text(node.get.text[self.text_box], l_data.size_nums[self.text_box][6])
		else
			gui.set_text(node.get.text[self.text_box], l_data.mine_nums[6])
		end
		gui.set(node.get.boxes[self.text_box], "size.x", #(gui.get_text(node.get.text[self.text_box]))*5+3)
		set_stars_pos(self)
		end

	if self.text_box < 3 and tonumber(gui.get_text(node.get.text[self.text_box])) < 1 then
		if #gui.get_text(node.get.text[self.text_box]) > 1 then
			gui.set(node.get.boxes[self.text_box], "size.x", 8)
		end
		gui.set_text(node.get.text[self.text_box], "1")
	end
	
	if tonumber(gui.get_text(node.get.text[self.text_box])) > 32 and self.text_box < 3 then
		gui.set_text(node.get.text[self.text_box], "32")
	end
	if tonumber(gui.get_text(node.get.text[3])) > tonumber(gui.get_text(node.get.text[1]))*tonumber(gui.get_text(node.get.text[2]))-1 then
		gui.set_text(node.get.text[3], ""..tonumber(gui.get_text(node.get.text[1]))*tonumber(gui.get_text(node.get.text[2]))-1)
		gui.set(node.get.boxes[3], "size.x", #(gui.get_text(node.get.text[3]))*5+3)
		set_stars_pos(self, true)
		l_data.mine_nums[6] = tonumber(gui.get_text(node.get.text[3]))
	end

	while #gui.get_text(node.get.text[self.text_box]) > 1 and string.sub(gui.get_text(node.get.text[self.text_box]), 1, 1) == "0" do
		gui.set_text(node.get.text[self.text_box], string.sub(gui.get_text(node.get.text[self.text_box]), 2))
		gui.set(node.get.boxes[self.text_box], "size.x", #(gui.get_text(node.get.text[self.text_box]))*5+3)
		set_stars_pos(self)
	end
	
	if self.text_box < 3 then
		l_data.size_nums[self.text_box][6] = tonumber(gui.get_text(node.get.text[self.text_box]))
	else
		l_data.mine_nums[6] = tonumber(gui.get_text(node.get.text[self.text_box]))
	end
	
	msg.post("/zoom#minefinder", "editing_dimensions", {editing = false})
	self.editing_dimensions = false

	if l_data.mine_nums[6] == calc_mine_ct(self) then
		self.mines_calced = true
		gui.set(node.get.stars, "color.w", 0)
		gui.set(node.get.stars_lit, "color.w", 0)
		else
		self.mines_calced = false
		gui.set(node.get.stars, "color.w", 1)
	end

	if gui.get_text(node.get.text[1]) == "11" and gui.get_text(node.get.text[2]) == "23" and gui.get_text(node.get.text[3]) == "58" then
		l_data.size_nums[1][6] = 16
		l_data.size_nums[2][6] = 16
		l_data.seconds = 0
		self.seconds_storage = -1
		l_data.minutes = 0
		l_data.hours = 0
		l_data.ticking = false
		l_data.snake = true
		gui.set(gui.get_node("post-it"), "color.w", 1)
	elseif l_data.snake and not l_data.snake_moving then
		l_data.size_nums[1][6] = tonumber(gui.get_text(node.get.text[1]))
		l_data.size_nums[2][6] = tonumber(gui.get_text(node.get.text[2]))
		gui.set(gui.get_node("post-it"), "color.w", 0)
		l_data.snake = false
		force_reset = true
	end

	if not l_data.more_settings and gui.get_text(node.get.text[1]) == "12" and gui.get_text(node.get.text[2]) == "24" and gui.get_text(node.get.text[3]) == "227" then
		l_data.more_settings = true
		msg.post("/settings#settings", "hidden-settings")
	end
	
	self.text_box = nil
	if force_reset or l_data.size_nums[1][6] ~= orig_rows or l_data.size_nums[2][6] ~= orig_cols or l_data.mine_nums[6] ~= orig_mines then
		msg.post("/zoom#minefinder", "reset", {change_diff = true})
	end

	l_data.highscore[l_data.diff] = l_data.custom_hs_list[l_data.size_nums[1][6]][l_data.size_nums[2][6]][l_data.mine_nums[6]+1]
	
	if l_data.highscore[l_data.diff] then
		local seconds = math.floor(l_data.highscore[l_data.diff]%60)
		local minutes = math.floor(l_data.highscore[l_data.diff]/60)
		local hours = 0
		if minutes >= 100 then
			hours = math.floor(minutes/60)
			minutes = minutes%60
		end

		local seconds_txt = ""..seconds
		local minutes_txt = ""..minutes
		local hours_txt = ""..hours

		if hours < 1 then
			if seconds < 10 then
				seconds_txt = "0" .. seconds_txt
			end
		elseif minutes < 10 then
			minutes_txt = "0"..minutes_txt
		end

		if hours < 1 then
			gui.set_text(gui.get_node("highscore"), minutes_txt .. ":".. seconds_txt)
		else
			local m_txt = "m"
			if hours >= 10 then
				m_txt = ""
			end
			gui.set_text(gui.get_node("highscore"), hours_txt.."h"..minutes_txt..m_txt)
		end
	else
		gui.set_text(gui.get_node("highscore"), "-:--")
	end
end

local function nochange(self)
	print("nochange")
	if self.text_box < 3 then
		if not l_data.snake then
			gui.set_text(node.get.text[self.text_box], l_data.size_nums[self.text_box][6])
		else
			if self.text_box == 1 then
				gui.set_text(node.get.text[self.text_box], "11")
			else
				gui.set_text(node.get.text[self.text_box], "23")
			end
		end
	else
		gui.set_text(node.get.text[self.text_box], l_data.mine_nums[6])
	end
	gui.set(node.get.boxes[self.text_box], "size.x", #(gui.get_text(node.get.text[self.text_box]))*5+3)
	set_stars_pos(self)
	if not l_data.snake then
		deselect_txt(self)
	else
		gui.set_color(self.outlines[self.text_box], vmath.vector4((34/255), (32/255), (52/255), 1))
		gui.set_color(node.get.text[self.text_box], vmath.vector4(1, 1, 1, 1))
		self.text_box = nil
	end
end

local function set_nodes(self)
	node.get.input_box_top = gui.get_node("input-box-top")
	node.get.input_box_bot = gui.get_node("input-box-bot")
	node.get.retry_hit = gui.get_node("retry")
	node.get.retry = gui.get_node("retry-bg")
	node.get.retry_lit = gui.get_node("retry-shadow")
	node.get.anim_sel = gui.get_node("anim-switch-select")
	node.get.anim_sel_bg = gui.get_node("anim-switch-select-bg")
	node.get.anim_sel_light = gui.get_node("anim-switch-select-heavy-bg")
	node.get.theme_sel = gui.get_node("theme-switch-select")
	node.get.theme_sel_bg = gui.get_node("theme-switch-select-bg")
	node.get.theme_sel_light = gui.get_node("theme-switch-select-heavy-bg")
	node.get.more_box = gui.get_node("more-box")
	node.get.more_down = gui.get_node("more-box-down")
	node.get.more_lit = gui.get_node("more-lit")
	node.get.more_symbol = gui.get_node("more-symbol-mod")
	node.get.floppy = gui.get_node("floppy")
	node.get.floppy_lit = gui.get_node("floppy-lit")
	node.get.set_check = gui.get_node("set-check")
	node.get.set_check_hit = gui.get_node("set-hitbox")
	node.get.set_check_lit = gui.get_node("set-check-lit")
	node.get.cancel_x = gui.get_node("cancel-x")
	node.get.cancel_x_hit = gui.get_node("x-hitbox")
	node.get.cancel_x_lit = gui.get_node("cancel-x-lit")
	node.get.row_ct = gui.get_node("row-ct")
	node.get.col_ct = gui.get_node("col-ct")
	node.get.mine_ct = gui.get_node("mine-ct")
	node.get.text = {node.get.row_ct, node.get.col_ct, node.get.mine_ct}
	node.get.row_OL = gui.get_node("row-OL")
	node.get.col_OL = gui.get_node("col-OL")
	node.get.mine_OL = gui.get_node("mine-OL")
	node.get.boxes = {node.get.row_OL, node.get.col_OL, node.get.mine_OL}
	node.get.stars = gui.get_node("stars")
	node.get.stars_lit = gui.get_node("stars-lit")
	node.get.stars_hit = gui.get_node("stars-hit")
end

local function set_diff_details_blue(self, blue)
	local color
	if blue then
		color = vmath.vector4((203/255), (219/255), (252/255), 1)
	else
		color = vmath.vector4(1, 1, 1, 1)
	end
	gui.set_color(gui.get_node("trophy-mod-OL-V"), color)
	gui.set_color(gui.get_node("trophy-mod-OL-H"), color)
	gui.set_color(gui.get_node("highscore"), color)
	gui.set_color(gui.get_node("diff-header"), color)
	gui.set_color(gui.get_node("diff-description"), color)
	gui.set_color(node.get.row_ct, color)
	gui.set_color(node.get.col_ct, color)
	gui.set_color(node.get.mine_ct, color)
end

local function handle_response(self, id, response)
	print("connected")
	print(response.status, ";", response.response)
	print(type(response.response))
	if response.status == 0 then
		print("Couldn't connect")
	else
		local data = json.decode(response.response)
		for d = 1,5 do
			for i,l in ipairs(data.leaderboard[d]) do
				l_board.lb_instance[d][i] = {l[2], l[1], l[3]}
			end
			for i = #data.leaderboard[d]+1, 10 do
				l_board.lb_instance[d][i] = nil
			end
		end
	end

	if #l_board.lb_instance[l_data.diff] == 0 or (#l_board.lb_instance[l_data.diff] > 0 and l_data.highscore[l_data.diff] < l_board.lb_instance[l_data.diff][#l_board.lb_instance[l_data.diff]][2]) then
		local flash_world = true
		local j = 1
		local set_hs = nil
		while j <= #l_board.lb_instance[l_data.diff] and not set_hs do
			if l_board.lb_instance[l_data.diff][j][3] == l_data.player_id then
				set_hs = l_board.lb_instance[l_data.diff][j][2]
			end
			j = j + 1
		end
		if l_data.highscore[l_data.diff] >= 6000 then
			flash_world = false
		elseif set_hs and set_hs <= l_data.highscore[l_data.diff] then
			flash_world = false
		end

		if flash_world then
			msg.post("/settings#settings", "world-flash")
			msg.post("/settings#settings", "world-notif")
		end
	end
end

local function ping_server(msg, type)
	http.request("http://127.0.0.1:8000"..msg, type, handle_response)
end

local function pull_board(self)
	print("connecting...")
	ping_server("/lb_sort", "GET")
end

function init(self)
	gui.set_render_order(0)
	set_nodes(self)
	self.input_override = true
	self.outlines = {node.get.row_OL, node.get.col_OL, node.get.mine_OL}
	self.seconds_storage = -1
	self.minutes_storage = -1
	l_data.ticking = false
	self.save_seconds = nil
	self.save_minutes = nil
	self.save_hours = nil
	self.anim_s_state = 9
	self.anims_on = true
	self.more_anims = false
	self.prefer_switch_up = false -- determines which way the switch will move when in the middle
	self.theme = "dark"
	self.text_box = nil
	self.diff_colors = {vmath.vector4((55/255), (148/255), (110/255), 1), vmath.vector4((153/255), (229/255), (80/255), 1), vmath.vector4((251/255), (242/255), (54/255), 1), vmath.vector4((223/255), (113/255), (38/255), 1), vmath.vector4((172/255), (50/255), (50/255), 1), vmath.vector4((118/255), (66/255), (138/255), 1)}
	self.mines_calced = true
	self.key_color = vmath.vector4(0, 0, 0, 0)
	self.light_on = false
	self.editing_dimensions = false 

	self.firework_locs = {"a", "b", "c"}
	self.firework_ids = {1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5}
	self.firework_colors = {1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 10}
	
	msg.post("/graffiti#graffiti", "disable")
	msg.post("/anims#anims", "disable")
	msg.post("/gui-zoom#zoom", "disable")
	gui.set_color(node.get.retry_lit, vmath.vector4((63/255), (63/255), (116/255), 1))
	-- msg.post("/settings#settings", "disable")
	
	for i = 1, 32 do
		table.insert(l_data.custom_hs_list, {})
		for j = 1, 32 do
			table.insert(l_data.custom_hs_list[i], {})
		end
	end
			
end

function update(self, dt)
	if l_data.ticking and l_data.in_game then
		l_data.seconds = l_data.seconds + dt
	elseif gui.get_text(gui.get_node("timer")) ~= hash("-:--") and l_data.seconds == 0 and l_data.minutes == 0 then
		gui.set_text(gui.get_node("timer"), "-:--")
	end
	if l_data.seconds >= 60 then
		l_data.minutes = l_data.minutes + 1
		l_data.seconds = l_data.seconds - 60
	end
	if (l_data.hours > 0 and l_data.minutes >= 60) or l_data.minutes >= 100 then
		l_data.hours = l_data.hours + 1
		l_data.minutes = l_data.minutes - 60
	end
	if l_data.hours < 1 then
		if math.floor(l_data.seconds) ~= math.floor(self.seconds_storage) and l_data.ticking then
			local seconds_txt
			if l_data.seconds < 10 then
				seconds_txt = "0" .. math.floor(l_data.seconds)
			else
				seconds_txt = "" .. math.floor(l_data.seconds)
			end
			gui.set_text(gui.get_node("timer"), l_data.minutes..":"..seconds_txt)
			self.seconds_storage = l_data.seconds
		end
	else
		if l_data.minutes ~= self.minutes_storage and l_data.ticking then
			local minutes_txt
			if l_data.minutes < 10 then
				minutes_txt = "0" .. math.floor(l_data.minutes)
			else
				minutes_txt = "" .. math.floor(l_data.minutes)
			end
			local m_txt = "m"
			if l_data.hours >= 10 then
				m_txt = ""
			end			
			gui.set_text(gui.get_node("timer"), l_data.hours.."h"..minutes_txt..m_txt)
			self.minutes_storage = l_data.minutes
		end
	end

	if l_data.saved == false then
		self.save_seconds = self.save_seconds + dt
		if self.save_seconds > 60 then
			self.save_seconds = self.save_seconds - 60
			self.save_minutes = self.save_minutes + 1
			if self.save_minutes >= 60 then
				self.save_minutes = self.save_minutes - 60
				self.save_hours = self.save_hours + 1
			end
			local save_txt
			if self.save_hours < 1 then
				save_txt = self.save_minutes.."m"
				if self.save_minutes < 10 then
					save_txt = "~~"..save_txt
				end
			else
				save_txt = self.save_hours.."h"
				if self.save_hours < 10 then
					save_txt = "~~"..save_txt
				end
			end
			gui.set_text(gui.get_node("last-save-time"), save_txt)
		end
	end
	
	if self.graffiti_timer then
		if self.graffiti_timer <= 0 then
			if self.theme == "midnight" then
				msg.post("/graffiti#graffiti", "enable")
			end
			self.graffiti_timer = nil
		else
			self.graffiti_timer = self.graffiti_timer - dt
		end
	end

	if self.midnight_timer then
		if self.midnight_timer <= 0 then
			midnight_switch_on(self)
			self.midnight_timer = nil
		else
			self.midnight_timer = self.midnight_timer - dt
		end
	end
	
	if self.firework_timer then
		if self.firework_timer >= 0.4 then
			if self.firework_num > 9 then
				self.firework_timer = nil
			else
				local location = self.firework_locs[self.firework_num%3+1]
				local firework_id = self.firework_ids[self.firework_num+1]
				gui.set_color(gui.get_node("firework-"..location.."-color"), get_firework_color(self.firework_colors[self.firework_num+1]))
				gui.play_flipbook(gui.get_node("firework-"..location.."-white"), "firework-"..firework_id.."-white")
				gui.play_flipbook(gui.get_node("firework-"..location.."-color"), "firework-"..firework_id.."-color")
				self.firework_num = self.firework_num + 1
				self.firework_timer = dt
			end
		else
			self.firework_timer = self.firework_timer + dt
		end
	end
	
end

function on_message(self, message_id, message)
	if message_id == hash("load_game") then
		if not l_data.settings.tutorial then
			gui.set(gui.get_node("tutorial"), "color.w", 0)
		end
		self.theme = message.theme
		sprite.play_flipbook("/anim-switch", "switch-"..message.anims_on)
		l_data.gui_anims = message.anims[8]
		msg.post("/gui#door", "gui_anims", {on = message.anims[8]})
		self.anim_s_state = message.anims_on
		if message.anims_on == 1 then
			self.anims_on = true
		else
			self.anims_on = false
		end

		if l_data.door_state == "gone" then
			gui.set(gui.get_node("lightbulb"), "color.w", 1)
			self.lightbulb_there = true
		end

		if message.theme == "midnight" then
			self.light_on = true
			gui.play_flipbook(gui.get_node("lightbulb"), "lightbulb-lit")
			msg.post("/graffiti#graffiti", "enable")
		end

		if l_data.mine_nums[6] < 1000 then
			gui.set(node.get.stars, "position.x", 1212+#(""..l_data.mine_nums[6])*30)
			if gui.get(node.get.stars, "position.y") ~= 288 then
				gui.set(node.get.stars, "position.y", 288)
			end
		else
			gui.set(node.get.stars, "position", vmath.vector3(1290, 234, 0))
		end
		self.mines_calced = false
		
		if l_data.mine_nums[6] == calc_mine_ct(self) then
			self.mines_calced = true
		elseif l_data.diff == 6 then
			gui.set(node.get.stars, "color.w", 1)
		end

		if l_data.os == "web" then
			gui.set(gui.get_node("retry"), "position.x", 1104)
			gui.set(gui.get_node("floppy"), "color.w", 0)
			gui.set(gui.get_node("save-title"), "color.w", 0)
			gui.set(gui.get_node("last-save-txt"), "color.w", 0)
			gui.set(gui.get_node("last-save-time"), "color.w", 0)
			gui.set(gui.get_node("colon"), "color.w", 0)
			gui.set(gui.get_node("separator-3"), "color.w", 0)
		end
	elseif message_id == hash("set_ticking") then
		l_data.ticking = message.ticking
		if l_data.ticking then
			self.seconds_storage = l_data.seconds-1
		end
	elseif message_id == hash("set_mines") then
		self.mine_count = message.mines
		gui.set_text(gui.get_node("total-mines"), message.mines.." TOTAL")
	elseif message_id == hash("reset") then
		-- l_data.seconds = 55
		-- l_data.minutes = 34
		-- l_data.hours = 2
		l_data.seconds = 0
		l_data.minutes = 0
		l_data.hours = 0
		self.seconds_storage = -1
		self.minutes_storage = -1
		l_data.ticking = false
		msg.post(".", "set_flags", {num = message.mines})
	elseif message_id == hash("set_flags") then
		self.flag_count = message.num
		gui.set_text(gui.get_node("flags-left"), message.num.." LEFT")
		if message.num < 0 and gui.get_color(gui.get_node("flags-left")) == vmath.vector4(1, 1, 1, 1) then
			gui.set_color(gui.get_node("flags-left"), vmath.vector4(0.6, 0, 0, 1))
		elseif message.num >= 0 and gui.get_color(gui.get_node("flags-left")) == vmath.vector4(0.6, 0, 0, 1) then
			gui.set_color(gui.get_node("flags-left"), vmath.vector4(1, 1, 1, 1))
		end
	elseif message_id == hash("update_switch") then
		if message.index < 9 then
			self.anim_s_state = self.anim_s_state + message.move
			sprite.play_flipbook("/anim-switch", "switch-"..self.anim_s_state)
		end
		if message.index == 8 then
			if message.move == 1 then
				l_data.gui_anims = true
				msg.post("/gui#door", "gui_anims", {on = true})
			else
				l_data.gui_anims = false
				msg.post("/gui#door", "gui_anims", {on = false})
			end
		end
	elseif message_id == hash("switch_preference") then
		self.prefer_switch_up = message.prefer_up
	elseif message_id == hash("set_hs") then
		if l_data.highscore[l_data.diff] == nil or math.floor(l_data.seconds + l_data.minutes*60 + l_data.hours*3600) < l_data.highscore[l_data.diff] then
			l_data.highscore[l_data.diff] = math.floor(l_data.seconds + l_data.minutes*60 + l_data.hours*3600)
			l_data.custom_hs_list[l_data.size_nums[1][l_data.diff]][l_data.size_nums[2][l_data.diff]][l_data.mine_nums[l_data.diff]+1] = l_data.highscore[l_data.diff]
			
			if l_data.diff == 6 then
				for i = 1, 5 do
					if l_data.size_nums[1][6] == l_data.size_nums[1][i] and l_data.size_nums[2][6] == l_data.size_nums[2][i] and l_data.mine_nums[6] == l_data.mine_nums[i] then
						l_data.highscore[i] = math.floor(l_data.seconds + l_data.minutes*60 + l_data.hours*3600)
						break
					end
				end
			end

			if l_data.diff ~= 6 then
				if l_board.lb_instance == nil then
					msg.post("/settings#settings", "world-flash")
					msg.post("/settings#settings", "world-notif")
				else
					pull_board(self)
				end
			end

			shuffle(self.firework_locs)
			shuffle(self.firework_ids)
			shuffle(self.firework_colors)
			self.firework_num = 0
			self.firework_timer = 0
			gui.play_flipbook(gui.get_node("exclamation"), "exclamation-flash")
			
			if l_data.hours < 1 then
				local seconds_txt
				if l_data.seconds < 10 then
					seconds_txt = "0" .. math.floor(l_data.seconds)
				else
					seconds_txt = "" .. math.floor(l_data.seconds)
				end
				gui.set_text(gui.get_node("highscore"), l_data.minutes .. ":".. seconds_txt)
			else
				local minutes_txt
				if l_data.minutes < 10 then
					minutes_txt = "0" .. math.floor(l_data.minutes)
				else
					minutes_txt = "" .. math.floor(l_data.minutes)
				end
				local m_txt = "m"
				if l_data.hours >= 10 then
					m_txt = ""
				end			
				gui.set_text(gui.get_node("highscore"), l_data.hours.."h"..minutes_txt..m_txt)
			end
		end
		msg.post("/zoom#minefinder", "save_game_msg")
	elseif message_id == hash("switch_hs") then
		local diffic = l_data.diff_temp
		local temporary = true
		if diffic == nil then
			diffic = l_data.diff
			temporary = false
		end

		local highscore = gui.get_node("highscore")
		local header = gui.get_node("diff-header")
		local description = gui.get_node("diff-description")


		if l_data.highscore[diffic] then
			local seconds = math.floor(l_data.highscore[diffic]%60)
			local minutes = math.floor(l_data.highscore[diffic]/60)
			local hours = 0
			if minutes >= 100 then
				hours = math.floor(minutes/60)
				minutes = minutes%60
			end

			local seconds_txt = ""..seconds
			local minutes_txt = ""..minutes
			local hours_txt = ""..hours

			if hours < 1 then
				if seconds < 10 then
					seconds_txt = "0" .. seconds_txt
				end
			elseif minutes < 10 then
				minutes_txt = "0"..minutes_txt
			end

			if hours < 1 then
				gui.set_text(highscore, minutes_txt .. ":".. seconds_txt)
			else
				local m_txt = "m"
				if hours >= 10 then
					m_txt = ""
				end			
				gui.set_text(highscore, hours_txt.."h"..minutes_txt..m_txt)
			end
		else
			gui.set_text(highscore, "-:--")
		end
		gui.set_color(gui.get_node("trophy-mod-C"), self.diff_colors[diffic])

		gui.set_text(header, l_data.header[diffic])
		gui.set_text(description, l_data.description[diffic])
		gui.set_text(node.get.row_ct, l_data.size_nums[1][diffic])
		gui.set_text(node.get.col_ct, l_data.size_nums[2][diffic])
		gui.set_text(node.get.mine_ct, l_data.mine_nums[diffic])

		if diffic == 5 and l_data.key_is_there then
			if temporary then
				msg.post("/gui#door", "key_color", {color = vmath.vector4((203/255), (219/255), (252/255), 1)})
				self.key_color = vmath.vector4((203/255), (219/255), (252/255), 1)
			else
				msg.post("/gui#door", "key_color", {color = vmath.vector4(1, 1, (215/255), 1)})
				self.key_color = vmath.vector4(1, 1, (215/255), 1)
			end
		elseif self.key_color.w ~= 0 then
			msg.post("/gui#door", "key_color", {color = vmath.vector4(0, 0, 0, 0)})
			self.key_color = vmath.vector4(0, 0, 0, 0)
		end
				
		if temporary then
			set_diff_details_blue(self, true)
		else
			set_diff_details_blue(self, false)
		end
		

		
		if l_data.diff_temp then
			if gui.get(node.get.set_check, "color.w") == 0 then
				if l_data.gui_anims then
					gui.play_flipbook(node.get.set_check, "check-appear")
					gui.play_flipbook(node.get.cancel_x, "x-appear")
				else
					gui.play_flipbook(node.get.set_check, "set-check4")
					gui.play_flipbook(node.get.cancel_x, "cancel-x4")
				end
				gui.set(node.get.set_check, "color.w", 1)
				gui.set(node.get.cancel_x, "color.w", 1)
			end
		else
			if gui.get(node.get.set_check, "color.w") == 1 then
				if l_data.gui_anims then
					gui.play_flipbook(node.get.set_check, "check-disappear", hide_floppy)
					gui.play_flipbook(node.get.cancel_x, "x-disappear", hide_x)
				else
					gui.set(node.get.set_check, "color.w", 0)
					gui.set(node.get.cancel_x, "color.w", 0)
				end
			end
		end

		if diffic == 6 and (gui.get(node.get.row_OL, "color.w") == 0 or gui.get_position(node.get.row_ct).x == 984) then
			local color = vmath.vector4((34/255), (32/255), (52/255), 1)
			if temporary then
				color = vmath.vector4((203/255), (219/255), (252/255), 1)
			end
			gui.set_color(node.get.row_OL, color)
			gui.set_color(node.get.col_OL, color)
			gui.set_color(node.get.mine_OL, color)
			if not self.mines_calced then
				gui.set(node.get.stars, "color.w", 1)
			end
			gui.set(node.get.row_ct, "position.x", 984-6)
			gui.set(node.get.col_ct, "position.x", 1032+6)
			gui.set(node.get.mine_ct, "position.x", 1194+6)
			gui.set(node.get.row_OL, "size.x", #tostring(l_data.size_nums[1][diffic])*5+3)
			gui.set(node.get.col_OL, "size.x", #tostring(l_data.size_nums[2][diffic])*5+3)
			gui.set(node.get.mine_OL, "size.x", #tostring(l_data.mine_nums[diffic])*5+3)
		elseif diffic ~= 6 and gui.get(node.get.row_OL, "color.w") == 1 then
			gui.set(node.get.row_OL, "color.w", 0)
			gui.set(node.get.col_OL, "color.w", 0)
			gui.set(node.get.mine_OL, "color.w", 0)
			gui.set(node.get.stars, "color.w", 0)
			gui.set(node.get.row_ct, "position.x", 984)
			gui.set(node.get.col_ct, "position.x", 1032)
			gui.set(node.get.mine_ct, "position.x", 1194)
		end
	elseif message_id == hash("lightbulb_gotten") then
		gui.set(gui.get_node("lightbulb"), "color.w", 1)
		self.lightbulb_there = true
	elseif message_id == hash("setup_snake_score") then
		gui.set_text(gui.get_node("total-mines"), 0)
		gui.set_text(gui.get_node("flags-left"), l_data.s_hs)
	elseif message_id == hash("update_snake_score") then
		local score = tonumber(gui.get_text(gui.get_node("total-mines"))) + 1
		gui.set_text(gui.get_node("total-mines"), score)
		if score > l_data.s_hs then
			l_data.s_hs = score
			gui.set_text(gui.get_node("flags-left"), score)
		end
	elseif message_id == hash("zoom_click") then
		zoom_in(self)
	elseif message_id == hash("set_props") then
		local seconds_txt = ""
		if l_data.hours < 1 then
			local seconds_txt
			if l_data.seconds < 10 then
				seconds_txt = "0" .. math.floor(l_data.seconds)
			else
				seconds_txt = "" .. math.floor(l_data.seconds)
			end
			gui.set_text(gui.get_node("timer"), l_data.minutes..":"..seconds_txt)
			self.seconds_storage = l_data.seconds
		else
			local minutes_txt
			if l_data.minutes < 10 then
				minutes_txt = "0" .. math.floor(l_data.minutes)
			else
				minutes_txt = "" .. math.floor(l_data.minutes)
			end
			local m_txt = "m"
			if l_data.hours >= 10 then
				m_txt = ""
			end			
			gui.set_text(gui.get_node("timer"), l_data.hours.."h"..minutes_txt..m_txt)
			self.minutes_storage = l_data.minutes
		end
		if message.highscore then
			msg.post(".", "set_hs")
		end
	elseif message_id == hash("full_board_anim") then
		self.full_board_anim = message.anim
		if message.anim then
			gui.set(gui.get_node("zoom-in"), "color.w", 0)
		elseif (l_data.size_nums[1][l_data.diff] > 16 or l_data.size_nums[2][l_data.diff] > 16) then
			gui.set(gui.get_node("zoom-in"), "color.w", 1)
		end
	elseif message_id == hash("set_tutorial_type") then
		gui.set(gui.get_node(""..message.show.."-tutorial"), "color.w", 1)
		gui.set(gui.get_node(""..message.hide.."-tutorial"), "color.w", 0)
	elseif message_id == hash("set_tutorial") then
		gui.set(gui.get_node("tutorial"), "color.w", message.alpha)
	elseif message_id == hash("start_saving") then
		l_data.saved = nil
		gui.play_flipbook(node.get.floppy, "floppy-grey")
		gui.set_text(gui.get_node("save-title"), "...")
	elseif message_id == hash("done_saving") then
		l_data.saved = true
		gui.play_flipbook(node.get.floppy, "floppy-check")
		gui.set_text(gui.get_node("save-title"), "SAVED")
		gui.set_text(gui.get_node("last-save-time"), "~~--")
		self.save_seconds = nil
		self.save_minutes = nil
		self.save_hours = nil
		if l_data.save_quit then
			sys.exit(0)
		end
	elseif message_id == hash("unsaved") then
		if l_data.saved == true and l_data.os ~= "web" then
			gui.play_flipbook(node.get.floppy, "floppy")
			gui.set_text(gui.get_node("save-title"), "SAVE")
			gui.set_text(gui.get_node("last-save-time"), "~~0m")
			l_data.saved = false
			self.save_seconds = 0
			self.save_minutes = 0
			self.save_hours = 0
		end
	elseif message_id == hash("stop_celebration") then
		if self.firework_timer then
			self.firework_timer = nil
			gui.play_flipbook(gui.get_node("exclamation"), "nothing")
			for i,k in ipairs(self.firework_locs) do
				gui.play_flipbook(gui.get_node("firework-"..k.."-white"), "nothing")
				gui.play_flipbook(gui.get_node("firework-"..k.."-color"), "nothing")
			end
		end
	end
end



function on_input(self, action_id, action)
	if self.input_override or gui.pick_node(node.get.input_box_top, action.x, action.y) then -- input top half
		if gui.pick_node(node.get.more_box, action.x, action.y) then -- more anims button
			self.input_override = true
			if gui.get_color(node.get.more_lit) ~= vmath.vector4(0, 0, 0, 0.2) then
				gui.set_color(node.get.more_lit, vmath.vector4(0, 0, 0, 0.2))
				msg.post("/zoom#minefinder", "hide_select", {hid = true})
			end
			if action.pressed and action_id == hash("touch") and gui.get_color(node.get.more_down) ~= vmath.vector4(1, 1, 1, 1) then
				msg.post("/sfx#sfx", "button2-depress")
				gui.set_color(node.get.more_down, vmath.vector4(1, 1, 1, 1))
			elseif action.released and action_id == hash("touch") and gui.get_color(node.get.more_down) ~= vmath.vector4(0, 0, 0, 0) then
				msg.post("/sfx#sfx", "button2-release")
				gui.set_color(node.get.more_down, vmath.vector4(0, 0, 0, 0))
				self.more_anims = not self.more_anims
				msg.post("/gui#door", "more_anims?", {anims = self.more_anims})
				msg.post("/zoom#minefinder", "more_anims", {shown = self.more_anims})
				if self.more_anims then
					gui.set_color(node.get.more_symbol, vmath.vector4(0, 0, 0, 0))
					msg.post("/anims#anims", "enable")
				else
					gui.set_color(node.get.more_symbol, vmath.vector4(1, 1, 1, 1))
					msg.post("/anims#anims", "disable")
				end
			end 
		else
			if gui.get_color(node.get.more_lit) ~= vmath.vector4(0, 0, 0, 0) then
				gui.set_color(node.get.more_lit, vmath.vector4(0, 0, 0, 0))
				msg.post("/zoom#minefinder", "hide_select", {hid = false})
				self.input_override = false
			end
			if gui.get_color(node.get.more_down) ~= vmath.vector4(0, 0, 0, 0) then
				gui.set_color(node.get.more_down, vmath.vector4(0, 0, 0, 0))
				self.input_override = false
			end
		end

		if self.lightbulb_there and gui.pick_node(gui.get_node("lightbulb-hit"), action.x, action.y) and not self.midnight_timer then --lightbulb
			self.input_override = true
			if action.pressed and action_id == hash("touch") then --click
				msg.post("/sfx#sfx", "switch")
				gui.set_color(gui.get_node("lightbulb-click"), vmath.vector4(1, 1, 1, 1))
			elseif action.released and action_id == hash("touch") and gui.get(gui.get_node("lightbulb-click"), "color.x") == 1 then --release
				msg.post("/sfx#sfx", "key-snap")
				-- print("switch!")
				self.light_on = not self.light_on
				if self.light_on then
					gui.set_color(gui.get_node("lightbulb-click"), vmath.vector4((142/255), (149/255), (219/255), 1))
					if self.theme == "light" and l_data.gui_anims then
						self.theme = "midnight"
						sprite.play_flipbook("/light-switch", "light-switch-off")
						msg.post("/zoom#minefinder", "set_theme", {theme = "dark"})
						self.midnight_timer = 0.15
					else
						midnight_switch_on(self)
					end
				else
					midnight_switch_off(self)
				end
			elseif gui.get(gui.get_node("lightbulb-click"), "color.w") == 0 then --hover
				msg.post("/zoom#minefinder", "hide_select", {hid = true})
				if self.light_on then
					gui.set_color(gui.get_node("lightbulb-click"), vmath.vector4((142/255), (149/255), (219/255), 1))
				else
					gui.set_color(gui.get_node("lightbulb-click"), vmath.vector4((203/255), (219/255), (252/255), 1))
				end
			end
		elseif gui.get(gui.get_node("lightbulb-click"), "color.w") ~= 0 then --unhover
			msg.post("/zoom#minefinder", "hide_select", {hid = false})
			gui.set(gui.get_node("lightbulb-click"), "color.w", 0)
			self.input_override = false
		end

		if gui.pick_node(node.get.anim_sel, action.x, action.y) then --switch click
			self.input_override = true
			if gui.get_color(node.get.anim_sel_bg) ~= vmath.vector4(1, 1, 1, 1) then
				msg.post("/zoom#minefinder", "hide_select", {hid = true})
				gui.set_color(node.get.anim_sel_bg, vmath.vector4(1, 1, 1, 1))
			end
			if not self.editing_dimensions and action_id == hash("touch") and action.pressed and gui.get_color(node.get.anim_sel_light) ~= vmath.vector4(1, 1, 1, 1) then
				msg.post("/sfx#sfx", "key-click")
				gui.set_color(node.get.anim_sel_light, vmath.vector4(1, 1, 1, 1))
			elseif action.released and action_id == hash("touch") and gui.get_color(node.get.anim_sel_light) == vmath.vector4(1, 1, 1, 1) then
				msg.post("/sfx#sfx", "switch")
				if gui.get_color(node.get.anim_sel_light) ~= vmath.vector4(0, 0, 0, 0) then
					gui.set_color(node.get.anim_sel_light, vmath.vector4(0, 0, 0, 0))
				end
				
				if self.anim_s_state == 9 then
					sprite.play_flipbook("/anim-switch", "switch-off")
					self.anim_s_state = 1
					msg.post("/zoom#minefinder", "set_anims", {anims = false})
					self.anims_on = false
					l_data.gui_anims = false
					msg.post("/gui#door", "gui_anims", {on = false})
					msg.post("/zoom#minefinder", "purge_instances")
				elseif self.anim_s_state == 1 then
					sprite.play_flipbook("/anim-switch", "switch-on")
					self.anim_s_state = 9
					msg.post("/zoom#minefinder", "set_anims", {anims = true})
					self.anims_on = true
					l_data.gui_anims = true
					msg.post("/gui#door", "gui_anims", {on = true})
				elseif not self.prefer_switch_up then
					self.anim_s_state = 1
					sprite.play_flipbook("/anim-switch", "switch-1")
					msg.post("/zoom#minefinder", "set_anims", {anims = false})
					self.anims_on = false
					l_data.gui_anims = false
					msg.post("/gui#door", "gui_anims", {on = false})
					msg.post("/zoom#minefinder", "purge_instances")
				else
					if self.anim_s_state < 2 then
						sprite.play_flipbook("/anim-switch", "switch-on")
					elseif self.anim_s_state < 5 then
						sprite.play_flipbook("/anim-switch", "switch-on-mid")
					elseif self.anim_s_state < 8 then
						sprite.play_flipbook("/anim-switch", "switch-on-end")
					else
						sprite.play_flipbook("/anim-switch", "switch-9")
					end
					self.anim_s_state = 9
					msg.post("/zoom#minefinder", "set_anims", {anims = true})
					self.anims_on = true
					l_data.gui_anims = true
					msg.post("/gui#door", "gui_anims", {on = true})
				end
				-- self.anims_on = not self.anims_on
				msg.post("/anims#anims", "switch_clicked", {setting = self.anims_on})
			end
		else
			if gui.get_color(node.get.anim_sel_bg) ~= vmath.vector4(0, 0, 0, 0) then
				msg.post("/zoom#minefinder", "hide_select", {hid = false})
				gui.set_color(node.get.anim_sel_bg, vmath.vector4(0, 0, 0, 0))
				self.input_override = false
			end
			if gui.get_color(node.get.anim_sel_light) ~= vmath.vector4(0, 0, 0, 0) then
				gui.set_color(node.get.anim_sel_light, vmath.vector4(0, 0, 0, 0))
				self.input_override = false
			end
		end

		if not self.more_anims and gui.pick_node(node.get.theme_sel, action.x, action.y) then --theme switch click
			self.input_override = true
			if gui.get_color(node.get.theme_sel_bg) ~= vmath.vector4(1, 1, 1, 1) then
				gui.set_color(node.get.theme_sel_bg, vmath.vector4(1, 1, 1, 1))
			end
			if action.pressed and action_id == hash("touch") and gui.get_color(node.get.theme_sel_light) ~= vmath.vector4(1, 1, 1, 1) then
				msg.post("/sfx#sfx", "key-click")
				gui.set_color(node.get.theme_sel_light, vmath.vector4(1, 1, 1, 1))
			elseif action.released and action_id == hash("touch") and gui.get(node.get.theme_sel_light, "color.w") == 1 then
				msg.post("/sfx#sfx", "switch")
				if gui.get_color(node.get.theme_sel_light) ~= vmath.vector4(0, 0, 0, 0) then
					gui.set_color(node.get.theme_sel_light, vmath.vector4(0, 0, 0, 0))
				end
				
				if self.theme == "dark" then
					if l_data.gui_anims then
						sprite.play_flipbook("/light-switch", "light-switch-on")
					else
						sprite.play_flipbook("/light-switch", "light-switch5")
					end
					self.theme = "light"
					msg.post("/zoom#minefinder", "set_theme", {theme = "light"})
				elseif self.theme == "light" then
					if l_data.gui_anims then
						sprite.play_flipbook("/light-switch", "light-switch-off")
					else
						sprite.play_flipbook("/light-switch", "light-switch1")
					end
					self.theme = "dark"
					msg.post("/zoom#minefinder", "set_theme", {theme = "dark"})
				elseif self.theme == "midnight" then
					self.light_on = not self.light_on
					midnight_switch_off(self)
				end
			end
		else
			if gui.get_color(node.get.theme_sel_bg) ~= vmath.vector4(0, 0, 0, 0) then
				gui.set_color(node.get.theme_sel_bg, vmath.vector4(0, 0, 0, 0))
				self.input_override = false
			end
			if gui.get_color(node.get.theme_sel_light) ~= vmath.vector4(0, 0, 0, 0) then
				gui.set_color(node.get.theme_sel_light, vmath.vector4(0, 0, 0, 0))
				self.input_override = false
			end
		end

		if not self.more_anims and gui.get(node.get.set_check, "color.w") == 1 and gui.pick_node(node.get.set_check_hit, action.x, action.y) then --set new diff (check)
			self.input_override = true
			if action.pressed and action_id == hash("touch") then
				msg.post("/sfx#sfx", "switch")
				gui.set(node.get.set_check_lit, "color.w", 1)
			elseif action.released and action_id == hash("touch") then
				msg.post("/sfx#sfx", "button1-release")
				gui.set(node.get.set_check_lit, "color.w", 0)
				gui.set(node.get.set_check, "color.w", 0)

				if l_data.diff_temp == 6 then
					gui.set_color(node.get.row_OL, vmath.vector4((34/255), (32/255), (52/255), 1))
					gui.set_color(node.get.col_OL, vmath.vector4((34/255), (32/255), (52/255), 1))
					gui.set_color(node.get.mine_OL, vmath.vector4((34/255), (32/255), (52/255), 1))
				end
				
				if l_data.gui_anims then
					gui.play_flipbook(node.get.cancel_x, "x-disappear", hide_x)
				else
					gui.set(node.get.cancel_x, "color.w", 0)
				end
				set_diff_details_blue(self, false)
				if l_data.diff_temp == 5 and l_data.key_is_there then
					msg.post("/gui#door", "key_color", {color = vmath.vector4(1, 1, (215/255), 1)})
					self.key_color = vmath.vector4(1, 1, (215/255), 1)
				end
				l_data.snake = false
				gui.set(gui.get_node("post-it"), "color.w", 0)
				msg.post("/zoom#minefinder", "set_diff")
				msg.post("/zoom#minefinder", "reset", {change_diff = true})
				msg.post("/zoom#minefinder", "hide_select", {hid = false})
			elseif gui.get(node.get.set_check_lit, "color.w") == 0 then
				gui.set(node.get.set_check_lit, "color.w", 0.4)
				msg.post("/zoom#minefinder", "hide_select", {hid = true})
			end
		elseif gui.get(node.get.set_check_lit, "color.w") ~= 0 then
			gui.set(node.get.set_check_lit, "color.w", 0)
			msg.post("/zoom#minefinder", "hide_select", {hid = false})
			self.input_override = false
		end


		if not self.more_anims and gui.get(node.get.cancel_x, "color.w") == 1 and gui.pick_node(node.get.cancel_x_hit, action.x, action.y) then --cancel new diff (x)
			self.input_override = true
			if action.pressed and action_id == hash("touch") then
				msg.post("/sfx#sfx", "switch")
				gui.set(node.get.cancel_x_lit, "color.w", 1)
			elseif action.released and action_id == hash("touch") then
				msg.post("/sfx#sfx", "button1-release")
				gui.set(node.get.cancel_x_lit, "color.w", 0)
				gui.set(node.get.cancel_x, "color.w", 0)
				l_data.diff_temp = l_data.diff
				msg.post("/zoom#minefinder", "set_diff")
				msg.post(".", "switch_hs")
				msg.post("/zoom#minefinder", "hide_select", {hid = false})
			elseif gui.get(node.get.cancel_x_lit, "color.w") == 0 then
				gui.set(node.get.cancel_x_lit, "color.w", 0.4)
				msg.post("/zoom#minefinder", "hide_select", {hid = true})
			end
		elseif gui.get(node.get.cancel_x_lit, "color.w") ~= 0 then
			gui.set(node.get.cancel_x_lit, "color.w", 0)
			msg.post("/zoom#minefinder", "hide_select", {hid = false})
			self.input_override = false
		end
	end
	if self.input_override or gui.pick_node(node.get.input_box_bot, action.x, action.y) then --input bottom half
		if (gui.pick_node(node.get.retry_hit, action.x, action.y) and not self.more_anims) then -- retry button
			self.input_override = true
			retry_but_on(self, action, action_id)
		elseif gui.get_color(node.get.retry_lit) == vmath.vector4((203/255), (219/255), (252/255), 1) then
			retry_but_off(self, action, action_id)
			self.input_override = false
		end
		
		if not self.more_anims and l_data.diff == 6 and l_data.diff_temp == nil then -- custom text boxes
			for i = 1, 3 do
				if gui.pick_node(self.outlines[i], action.x, action.y) then 
					self.input_override = true
					if gui.get_color(self.outlines[i]) == vmath.vector4((34/255), (32/255), (52/255), 1) then
						msg.post("/zoom#minefinder", "hide_select", {hid = true})
						gui.set_color(self.outlines[i], vmath.vector4((63/255), (63/255), (116/255), 1))
					end
					if gui.get_color(self.outlines[i]) == vmath.vector4((107/255), (160/255), (255/255), 1) then
						msg.post("/zoom#minefinder", "hide_select", {hid = true})
						gui.set_color(self.outlines[i], vmath.vector4((203/255), (219/255), (252/255), 1))
					end				
					if action.pressed and action_id == hash("touch") and gui.get_color(self.outlines[i]) ~= vmath.vector4(1, 1, 1, 1) then
						gui.set_color(self.outlines[i], vmath.vector4(1, 1, 1, 1))
					elseif action.released and action_id == hash("touch") and gui.get_color(self.outlines[i]) == vmath.vector4(1, 1, 1, 1) then
						msg.post("/zoom#minefinder", "editing_dimensions", {editing = true})
						self.editing_dimensions = true
						self.text_box = i
						gui.set_color(self.outlines[i], vmath.vector4((203/255), (219/255), (252/255), 1))
						gui.set_color(node.get.text[self.text_box], vmath.vector4((172/255), (204/255), (255/255), 1))
					end
				elseif gui.get_color(self.outlines[i]) ~= vmath.vector4((34/255), (32/255), (52/255), 1) and gui.get_color(self.outlines[i]) ~= vmath.vector4((107/255), (160/255), (255/255), 1) then
					if i == self.text_box then
						gui.set_color(self.outlines[i], vmath.vector4((107/255), (160/255), (255/255), 1))
					else
						gui.set_color(self.outlines[i], vmath.vector4((34/255), (32/255), (52/255), 1))
					end
					msg.post("/zoom#minefinder", "hide_select", {hid = false})
					self.input_override = false
				elseif action.pressed and i == self.text_box and action_id == hash("touch") then
					if l_data.snake_moving then
						nochange(self)
					else
						deselect_txt(self)
					end
				end
			end
		end
		
		if l_data.diff == 6 and not self.mines_calced and not self.more_anims and gui.pick_node(node.get.stars_hit, action.x, action.y) then -- stars
			self.input_override = true
			if action.pressed and action_id == hash("touch") then --click
				gui.set(node.get.stars, "color.w", 0)
				gui.set(node.get.stars_lit, "position.y", -1)
			elseif action.released and action_id == hash("touch") then --release
				-- gui.set(node.get.stars, "color.w", 1)
				msg.post("/zoom#minefinder", "hide_select", {hid = false})
				gui.set(node.get.stars_lit, "color.w", 0)
				gui.set(node.get.stars_lit, "position.y", 0)
				gui.set_text(node.get.text[3], calc_mine_ct(self))
				self.text_box = 3
				gui.set(node.get.boxes[self.text_box], "size.x", #(gui.get_text(node.get.text[self.text_box]))*5+3)
				set_stars_pos(self)
				if l_data.snake_moving then
					nochange(self)
					gui.set(node.get.stars_lit, "position.y", 0)
					gui.set(node.get.stars_lit, "color.w", 1)
					gui.set(node.get.stars, "color.w", 1)
				else
					deselect_txt(self)
					self.mines_calced = true
				end
			elseif gui.get(node.get.stars_lit, "color.w") ~= 1 then --hover
				msg.post("/zoom#minefinder", "hide_select", {hid = true})
				gui.set(node.get.stars_lit, "color.w", 1)
			end
		elseif not self.mines_calced and gui.get(node.get.stars_lit, "color.w") == 1 then -- reset
			msg.post("/zoom#minefinder", "hide_select", {hid = false})
			gui.set(node.get.stars_lit, "color.w", 0)
			gui.set(node.get.stars_lit, "position.y", 0)
			if gui.get(node.get.stars, "color.w") == 0 then
				gui.set(node.get.stars, "color.w", 1)
			end
			self.input_override = false
		end

		if l_data.saved == false and not self.more_anims and l_data.os ~= "web" and gui.pick_node(node.get.floppy, action.x, action.y) and gui.get(node.get.floppy, "color.w") == 1 then --floppy disk click
			self.input_override = true
			if action.pressed and action_id == hash("touch") then
				gui.set_color(node.get.floppy_lit, vmath.vector4(1, 1, 1, 1))
			elseif action.released and action_id == hash("touch") and gui.get_color(node.get.floppy_lit) ==  vmath.vector4(1, 1, 1, 1) then
				gui.set(node.get.floppy_lit, "color.w", 0)
				l_data.saved = nil
				msg.post("/zoom#minefinder", "save_game_msg")
				msg.post("/zoom#minefinder", "hide_select", {hid = false})
			elseif gui.get(node.get.floppy_lit, "color.w") ~= 1 then
				gui.set_color(node.get.floppy_lit, vmath.vector4((91/255), (110/255), (225/255), 1))
				msg.post("/zoom#minefinder", "hide_select", {hid = true})
			end
		elseif gui.get(node.get.floppy_lit, "color.w") ~= 0 then
			gui.set(node.get.floppy_lit, "color.w", 0)
			msg.post("/zoom#minefinder", "hide_select", {hid = false})
			self.input_override = false
		end
	end

	if action_id == hash("retry") then -- retry button
		retry_but_on(self, action, action_id)
	elseif not self.input_override and gui.get_color(node.get.retry_lit) == vmath.vector4((203/255), (219/255), (252/255), 1) then
		retry_but_off(self, action, action_id)
	end
	
	if self.text_box and action.pressed and action_id == hash("enter") then --enter
		if l_data.snake_moving then
			nochange(self)
		else
			deselect_txt(self)
		end
	end 

	if self.text_box and action.pressed and action_id == hash("esc") then --escape
		nochange(self)
	end

	if action.pressed and self.text_box and action_id == hash("del") then --delete
		if gui.get_color(node.get.text[self.text_box]) == vmath.vector4((172/255), (204/255), (255/255), 1) then
			gui.set_text(node.get.text[self.text_box], "")
			gui.set_color(node.get.text[self.text_box], vmath.vector4(1, 1, 1, 1))
			gui.set(node.get.boxes[self.text_box], "size.x", 8)
			set_stars_pos(self)
		else
			gui.set_text(node.get.text[self.text_box], string.sub(gui.get_text(node.get.text[self.text_box]), 1, #gui.get_text(node.get.text[self.text_box])-1))
		end

		if #(gui.get_text(node.get.text[self.text_box]))*5+3 > 7 then
			gui.set(node.get.boxes[self.text_box], "size.x", #(gui.get_text(node.get.text[self.text_box]))*5+3)
			set_stars_pos(self)
		end
	end

	if action.pressed and self.text_box and action_id == hash("r-arr") then --right arrow
		gui.set_color(node.get.text[self.text_box], vmath.vector4(1, 1, 1, 1))
	end

	if action.pressed and self.text_box and action_id == hash("tab") then --tab
		local txt_b_old = self.text_box
		if l_data.snake_moving then
			nochange(self)
		else
			deselect_txt(self)
		end
		if self.shifting then
			self.text_box = (txt_b_old-2)%3 + 1
		else
			self.text_box = txt_b_old%3 + 1
		end

		msg.post("/zoom#minefinder", "editing_dimensions", {editing = true})
		self.editing_dimensions = true

		gui.set_color(node.get.text[self.text_box], vmath.vector4((172/255), (204/255), (255/255), 1))
		gui.set_color(self.outlines[self.text_box], vmath.vector4((107/255), (160/255), (255/255), 1))
	end	

	if action_id == hash("shift") then --shift condition
		if action.pressed then
			self.shifting = true
		elseif action.released then
			self.shifting = false
		end
	end	
	
	if action.pressed and hash_is_num(action_id) and self.text_box then --typing numbers
		if gui.get_color(node.get.text[self.text_box]) == vmath.vector4((172/255), (204/255), (255/255), 1) then
			gui.set_text(node.get.text[self.text_box], ""..hash_to_num(action_id))
			gui.set_color(node.get.text[self.text_box], vmath.vector4(1, 1, 1, 1))
		elseif #(gui.get_text(node.get.text[self.text_box])) < (2+math.floor(self.text_box/3)*2) then
			gui.set_text(node.get.text[self.text_box], gui.get_text(node.get.text[self.text_box])..hash_to_num(action_id))
		end

		gui.set(node.get.boxes[self.text_box], "size.x", #(gui.get_text(node.get.text[self.text_box]))*5+3)
		set_stars_pos(self)
	end

	if not self.editing_dimensions and (l_data.size_nums[1][l_data.diff] > 16 or l_data.size_nums[2][l_data.diff] > 16) and not self.full_board_anim then --zoom
		if gui.get(gui.get_node("zoom-in"), "color.w") == 0 then
			gui.set(gui.get_node("zoom-in"), "color.w", 1)
		elseif not self.editing_dimensions and action.pressed and action_id == hash("touch") and gui.pick_node(gui.get_node("zoom-in-hit"), action.x, action.y) then
			zoom_in(self)
		end
	elseif gui.get(gui.get_node("zoom-in"), "color.w") ~= 0 and (l_data.size_nums[1][l_data.diff] <= 16 or l_data.size_nums[2][l_data.diff] <= 16) then
		gui.set(gui.get_node("zoom-in"), "color.w", 0)
	end
	
	-- if action.pressed and (action_id == hash("debug")) then
	-- end
end
