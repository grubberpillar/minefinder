local function shuffle(tbl)
	for i = #tbl, 2, -1 do
		local j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end

local function mines_around(self, row, col)
	local counter = 0
	for r = -1, 1 do
		for c = -1, 1 do
			if row+r > 0 and row+r < self.size+1 and col+c > 0 and col+c < self.size+1 then
				if self.board[row+r][col+c] == 12 then 
					counter = counter + 1
				elseif self.board[row+r][col+c] == 14 then
					return 10
				end
			end
		end
	end
	return counter
end

local function spaces_around(self, row, col)
	local counter = 0
	for r = -1, 1 do
		for c = -1, 1 do
			if tilemap.get_tile("/zoom#board", "layer1", col+c+1, row+r+1) ~= 14 then
				counter = counter + 1
			end
		end
	end

	return counter
end

local function show_block(self, row, col)
	tilemap.set_tile("/zoom#board", "layer1", col+1, row+1, self.board[row][col])
	for r = -1, 1 do
		for c = -1, 1 do
			if row+r > 0 and row+r < self.size+1 and col+c > 0 and col+c < self.size+1 then
				if self.board[row+r][col+c] == 1  and (tilemap.get_tile("/zoom#board", "layer1", col+c+1, row+r+1) == 11 or tilemap.get_tile("/zoom#board", "layer1", col+c+1, row+r+1) == 13) then
					show_block(self, row+r, col+c)
				else
					tilemap.set_tile("/zoom#board", "layer1", col+c+1, row+r+1, 16)
				end
			end
		end
	end
end

function init(self)
	self.anims = {flag_place = true, flag_remove = true, flag_correct = true, flag_incorrect = true, explosion = true, timer = true, ui = true, tileflip = true, flip_bg = false}
	msg.post(".", "setup")
	-- resource.set_texture(path, table, buffer)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("setup") then
		self.board = {}
		self.size = 16
		self.offS = (16-self.size)/2
		self.numMines = 40
		self.playing = true
		self.hard_select = true
		self.wrong_flags = nil
		self.to_flip = {}
		self.timer = nil
		msg.post("/gui#minefinder", "set_resettable", {bool = true})

		msg.post(".", "acquire_input_focus")
		math.randomseed(socket.gettime())
	elseif message_id == hash("reset") then --checkpoint
		self.mine_locs = nil
		self.mine_i = nil
		self.timer = 0
		self.playing = false
		msg.post("/gui#minefinder", "reset")
		msg.post("/gui#minefinder", "set_resettable", {bool = false})
		for r = self.size+self.offS, 1+self.offS, -1 do
			for c = 1+self.offS, self.size+self.offS do
				if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) ~= 11 or self.anims.flip_bg then
					table.insert(self.to_flip, {r, c})
				end
			end
		end
		if #self.to_flip < 1 then
			msg.post(".", "setup")
		end
	end
	
end

function on_input(self, action_id, action)
	if (action_id == hash("touch") or action_id == hash("select")) and action.pressed and self.playing then
		local moveRow = math.floor(action.y/48)
		local moveCol = math.floor(action.x/48)
		if moveRow < self.size+1+self.offS and moveCol < self.size+1+self.offS and moveRow > self.offS and moveCol > self.offS then
			self.tile_clicked = tilemap.get_tile("/zoom#board", "layer1", moveCol+1, moveRow+1)
			self.row_clicked = moveRow
			self.col_clicked = moveCol
			tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 16)
		end
	end
	
	if self.tile_clicked and (action_id == hash("touch") or action_id == hash("select")) and action.released and self.playing then
		local moveRow = math.floor(action.y/48)
		local moveCol = math.floor(action.x/48)
		-- print(11-moveRow .. ", " .. moveCol)

		if moveRow < self.size+1+self.offS and moveCol < self.size+1+self.offS and moveRow > self.offS and moveCol > self.offS then
			if not self.board[1] then --first move
				self.board = {}
				for i = 1, self.size do
					table.insert(self.board, {})
				end

				for r = 1, self.size do -- setting the board up
					for c = 1, self.size do
						self.board[r][c] = 0
					end
				end

				self.board[moveRow][moveCol] = 14

				local count = 1
				while count <= self.numMines do -- adding mines
					local randRow = math.random(1+self.offS, self.size+self.offS)
					local randCol = math.random(1+self.offS, self.size+self.offS)
					if mines_around(self, randRow, randCol) < spaces_around(self, randRow, randCol) and self.board[randRow][randCol] ~= 12 then
						-- print(randRow .. ", " .. randCol)
						self.board[randRow][randCol] = 12
						count = count + 1
					end
					-- print(mines_around(self, randRow, randCol) .. ", " .. spaces_around(self, randRow, randCol))
				end

				self.board[moveRow][moveCol] = 1

				for r = 1, #self.board do
					for c = 1, #self.board[1] do
						if self.board[r][c] == 0 then
							self.board[r][c] = mines_around(self, r, c) + 1
						end
					end
				end

				show_block(self, moveRow, moveCol)
				self.flashing = true
				self.timer = 0.1
				msg.post("/gui#minefinder", "set_ticking", {ticking = true})
				
			else --NOT first move
				if self.tile_clicked == 13 then -- remove flag
					tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 11)
					if self.anims.flag_remove then
						local props = {type = 2}
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(moveCol*48+24, moveRow*48+24, 0.5), nil, props).."#flag"})
					end
				elseif action_id == hash("select") and self.tile_clicked == 11 then -- place flag
					tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 13)
					if self.anims.flag_place then
						local props = {type = 1}
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(moveCol*48+24, moveRow*48+24, 0.5), nil, props).."#flag"})
					end
				elseif self.tile_clicked > 10 then -- digging a tile
					if self.board[moveRow][moveCol] == 1 then -- flip tile
						show_block(self, moveRow, moveCol)
						self.flashing = true
						self.timer = 0.1
						
					elseif self.board[moveRow][moveCol] == 12 then -- flip mine
						tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow][moveCol])
						msg.post("/gui#minefinder", "set_ticking", {ticking = false})
						print("you lose!")
						self.playing = false
						if self.anims.explosion then
							local props = {wick = true}
							msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#explosion-factory", vmath.vector3(moveCol*48+24, moveRow*48+24, 0.5), nil, props).."#explosion"})
						end
						
						self.mine_locs = {}
						for r = 1, #self.board do
							for c = 1, #self.board[1] do
								if self.board[r][c] == 12 and not (r == moveRow and c == moveCol) then
									if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) == 13 then
										table.insert(self.mine_locs, {r, c, true})
									else
										table.insert(self.mine_locs, {r, c, false})
									end
								end
							end
						end
						shuffle(self.mine_locs)

						self.timer = 3
						self.mine_i = 1
					else -- reveal block
						tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow][moveCol])
						
					end
				else
					tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow][moveCol])
				end
				local flag_count = 0
				local won_game = true
				for r = 1, #self.board do
					for c = 1, #self.board[1] do
						if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) == 13 then
							flag_count = flag_count + 1
						end
						if won_game and tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) > 9 and self.board[r][c] < 10 then
							won_game = false
						end
					end
				end
				
				msg.post("/gui#minefinder", "set_flags", {num = flag_count})

				if won_game then
					print("you win!")
					msg.post("/gui#minefinder", "set_ticking", {ticking = false})
					
					for r = 1, #self.board do
						for c = 1, #self.board[1] do
							if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) == 11 then
								tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 13)
								if self.anims.flag_place then
									local props = {type = 1}
									msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(moveCol*48+24, moveRow*48+24, 0.5), nil, props).."#flag"})
								end
							end
						end
					end
					
					
				end
			end
		end
		self.tile_clicked = nil
		self.row_clicked = nil
		self.col_clicked = nil
	end

	local moveRow = math.floor(action.y/48)
	local moveCol = math.floor(action.x/48)
	if self.row_clicked and (self.row_clicked ~= moveRow or self.col_clicked ~= moveCol) then
		tilemap.set_tile("/zoom#board", "layer1", self.col_clicked+1, self.row_clicked+1, self.tile_clicked)
		self.tile_clicked = nil
		self.row_clicked = nil
		self.col_clicked = nil
	end
	-- tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 12)
	if moveCol > 17 and self.hard_select then
		sprite.play_flipbook("/selection", "frame-light")
		self.hard_select = false
	elseif moveCol < 18 and not self.hard_select then
		sprite.play_flipbook("/selection", "frame")
		self.hard_select = true
	end
	go.set("/selection", "position", vmath.vector3(moveCol*8+4, moveRow*8+4, 0.8))
	
end


function update(self, dt) --checkpoint
	-- print(self.timer, self.board[1], #self.to_flip)
	if self.timer and (self.board[1] or #self.to_flip > 0) then
		while (self.timer <= 0 or self.anims.timer == false) and (self.flashing or (self.mine_locs and self.mine_i <= #self.mine_locs) or #self.to_flip > 0) do
			-- print("acting")
			-- tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow][moveCol])
			if self.flashing then
				for r = 1, #self.board do
					for c = 1, #self.board[1] do
						if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) == 16 then
							tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, self.board[r][c])
						end
					end
				end
				self.flashing = false
			elseif #self.to_flip > 0 then
				if self.anims.tileflip then
					local props = {tile = tilemap.get_tile("/zoom#board", "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1)}
					factory.create("#flip-factory", vmath.vector3(self.to_flip[1][2]*48+24, self.to_flip[1][1]*48+24, 0.5), nil, props)
				end
				if self.anims.flip_bg then
					self.timer = 0.01
				else
					self.timer = 0.02
				end
				if #self.to_flip == 1 then
					msg.post(".", "setup")
				end
				table.remove(self.to_flip, 1)
			else
				local mineRow = self.mine_locs[self.mine_i][1]
				local mineCol = self.mine_locs[self.mine_i][2]
				if self.mine_locs[self.mine_i][3] then
					if self.anims.flag_correct then
						local props = {type = 3}
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(mineCol*48+24, mineRow*48+24, 0.5), nil, props).."#flag"})
					end
					tilemap.set_tile("/zoom#board", "layer1", mineCol+1, mineRow+1, 17)
				else
					tilemap.set_tile("/zoom#board", "layer1", mineCol+1, mineRow+1, self.board[mineRow][mineCol])
					if self.anims.explosion then
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#explosion-factory", vmath.vector3(mineCol*48+24, mineRow*48+24, 0.5)).."#explosion"})
					end
				end

				self.timer = 1/self.mine_i
				
				if self.mine_i == #self.mine_locs then
					self.wrong_flags = {}
					self.mine_i = 1000
					self.flag_i = 1	
					for r = #self.board, 1, -1 do
						for c = 1, #self.board[1] do
							if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) == 13 then
								table.insert(self.wrong_flags, {r, c})
							end
						end
					end
					-- shuffle(self.wrong_flags) --makes wrong flags show in random order
					self.timer = 2.5
				end
				self.mine_i = self.mine_i + 1
			end
		end
		while (self.timer <= 0 or self.anims.timer == false) and self.wrong_flags and self.flag_i <= #self.wrong_flags do
			local flagRow = self.wrong_flags[self.flag_i][1]
			local flagCol = self.wrong_flags[self.flag_i][2]
			if self.anims.flag_incorrect then
				local props = {type = 4}
				msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(flagCol*48+24, flagRow*48+24, 0.5), nil, props).."#flag"})
			end
			self.timer = 1
			self.flag_i = self.flag_i + 1
		end
		if (self.board[1] or #self.to_flip > 0) and self.flashing or (self.mine_locs and self.mine_i <= #self.mine_locs) or (self.wrong_flags and self.flag_i <= #self.wrong_flags) or #self.to_flip > 0 then
			self.timer = self.timer - dt
			-- print("time down")
		else 
			self.timer = nil
			-- print("NIL!")
		end
		-- print("self.timing")
	end	
end