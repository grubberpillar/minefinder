local l_data = require "main.leveldata"

local function save_game(self)
	local filename = sys.get_save_file("sys_save_load", "gamedata")
	local props = 
	{highscore = l_data.highscore, 
	custom_hs_list = l_data.custom_hs_list, 
	diff = l_data.diff,
	settings = l_data.settings,
	mine_nums = l_data.mine_nums, size_nums = l_data.size_nums, 
	theme = self.theme}
	
	sys.save(filename, {gamedata = props})
	msg.post("/gui#minefinder", "done_saving")
	print("saved")
end

local function load_game(self)
	local filename = sys.get_save_file("sys_save_load", "gamedata")
	local data = sys.load(filename)
	if data.gamedata then
		l_data.highscore = data.gamedata.highscore
		l_data.custom_hs_list = data.gamedata.custom_hs_list
		l_data.diff = data.gamedata.diff
		l_data.mine_nums = data.gamedata.mine_nums
		l_data.size_nums = data.gamedata.size_nums
		l_data.settings = data.gamedata.settings
		self.theme = data.gamedata.theme

		msg.post(".", "set_theme", {theme = data.gamedata.theme, startup = true})
		
		msg.post("/gui#minefinder", "load_game", {theme = self.theme})
		msg.post("/settings#settings", "load_game")
		msg.post("/gui#minefinder", "switch_hs")
	end
end

local function set_props(self)
	local old_mines = self.num_mines
	local old_row = self.row_size
	local old_col = self.col_size
	self.num_mines = l_data.mine_nums[l_data.diff]
	self.row_size = l_data.size_nums[1][l_data.diff]
	self.col_size = l_data.size_nums[2][l_data.diff]
	-- self.row_size = 15
	-- self.col_size = 15
	if self.row_size > 16 or self.col_size > 16 then
		self.mini_txt = "-mini"
		-- self.tiny_select = true
		self.tile_size = 4
		self.board_size = 32
		self.mini_offS = 1
		msg.post("/gui#minefinder", "set_tutorial_type", {show = 4, hide = 8})
	else
		self.mini_txt = ""
		self.tiny_select = false
		self.tile_size = 8
		self.board_size = 16
		self.mini_offS = 0
		msg.post("/gui#minefinder", "set_tutorial_type", {show = 8, hide = 4})
	end

	if self.snake_set or (old_mines ~= self.num_mines and self.game_started) or old_row ~= self.row_size or old_col ~= self.col_size or l_data.diff == 6 then 
		self.new_diff = true
		if self.snake_set then
			self.snake_set = false
		end
	end
	
	msg.post("/gui#minefinder", "set_mines", {mines = self.num_mines})
	msg.post("/gui#minefinder", "reset", {mines = self.num_mines})
end

local function shuffle(tbl)
	for i = #tbl, 2, -1 do
		local j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end

local function theme_to_id(theme)
	if theme == "dark" then
		return 0
	elseif theme == "light" then
		return 1
	else
		return 2
	end
end

local function mines_around(self, row, col)
	local counter = 0
	for r = -1, 1 do
		for c = -1, 1 do
			if row+r > 0 and row+r < self.row_size+1 and col+c > 0 and col+c < self.col_size+1 then
				if self.board[row+r][col+c] == 12 then 
					counter = counter + 1
				elseif self.board[row+r][col+c] == 14 then
					return 11
				end
			end
		end
	end
	return counter
end

local function spaces_around(self, row, col)
	local counter = 0
	for r = -1, 1 do
		for c = -1, 1 do
			if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", col+c+1, row+r+1) ~= 14 then
				counter = counter + 1
			end
		end
	end

	return counter
end

local function show_block(self, row, col)
	tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", col+1, row+1, self.board[row-self.row_offS-self.mini_offS][col-self.col_offS-self.mini_offS])
	for r = -1, 1 do
		for c = -1, 1 do
			if row+r > self.row_offS+self.mini_offS and row+r < self.row_size+1+self.row_offS+self.mini_offS and col+c > self.col_offS+self.mini_offS and col+c < self.col_size+1+self.col_offS+self.mini_offS then
				local tile
				tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", col+c+1, row+r+1)
				if self.board[row+r-self.row_offS-self.mini_offS][col+c-self.col_offS-self.mini_offS] == 1  and (tile == 11 or tile == 13) then
					show_block(self, row+r, col+c)
				else
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", col+c+1, row+r+1, 16)
					if self.zoomed then 
						local colref = col+c-(self.col_offS+self.zoom_offS.c)
						local rowref = row+r-(self.row_offS+self.row_size-16+self.zoom_offS.r)
						if colref > 1 and colref < 29 and rowref > 1 and rowref < 18 then 
							tilemap.set_tile("/zoom#board-zoom", "layer1", colref, rowref, 16)
						end
					end
				end
			end
		end
	end
end

local function in_snake(self, x, y)
	for i,s in ipairs(self.snake_segments) do
		if s.x == x and s.y == y then
			return true
		end
	end
	return false
end

local function put_food(self)
	self.food = {x = math.random(2, 17), y = math.random(2, 17)}
	if tilemap.get_tile("/zoom#board", "layer1", self.food.x, self.food.y) == 11 and not in_snake(self, self.food.x, self.food.y) then
		if self.anims["tileflip"] then
			local props = {final = 0, tile = 12, mini = 0, tile_size = 8, theme_id = theme_to_id(self.theme), reverse = 1}
			local id = factory.create("#flip-factory", vmath.vector3(self.food.x*48-24, self.food.y*48-24, 0.5), nil, props)
			self.food_url = id
			msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
		else
			tilemap.set_tile("/zoom#board", "layer1", self.food.x, self.food.y, 12)
		end		
	else
		put_food(self)
	end
end

local function count_t_flips(self)
	local count = 0
	for i,k in ipairs(self.instances) do
		if k[2] == "flip" then
			count = count+1
		end
	end
	if count == 0 then
		self.watch_t_flips = false
	end
	return count
end

local function update_zoom_board(self, zoomout)
	msg.post(".", "purge_instances")
	local tile
	for r = 2, 17 do
		for c = 2, 28 do
			if zoomout then
				tile = 20
			else
				local colref = c+1+self.col_offS+self.zoom_offS.c
				local rowref = r+1+self.row_offS+self.row_size-16+self.zoom_offS.r
				if rowref < 37 and colref < 36 and rowref > 0 and colref > 0 then
					tile = tilemap.get_tile("/zoom#board-mini", "layer1", colref, rowref)
				else
					tile = 14
				end
			end
			tilemap.set_tile("/zoom#board-zoom", "layer1", c, r, tile)
		end
	end
end

local function arrow_key_nav(self, dir, ignore_shift)
	if dir == "u" then
		self.zoom_offS_edited = true
		if self.zoom_offS.r < 0 then
			if self.zoom_offS.r == -1*(self.row_size-16) then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "s", alpha = 1})
			end
			if not self.shifting or ignore_shift then
				self.zoom_offS.r = self.zoom_offS.r+1
			else
				self.zoom_offS.r = 0
			end
			if self.zoom_offS.r == 0 then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "n", alpha = 0})
			end
			update_zoom_board(self)
		end
	elseif dir == "d" then
		self.zoom_offS_edited = true
		if self.zoom_offS.r > -1*(self.row_size-16) then
			if self.zoom_offS.r == 0 then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "n", alpha = 1})
			end
			if not self.shifting or ignore_shift then
				self.zoom_offS.r = self.zoom_offS.r-1
			else
				self.zoom_offS.r = -1*(self.row_size-16)
			end
			if self.zoom_offS.r == -1*(self.row_size-16) then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "s", alpha = 0})
			end
			update_zoom_board(self)
		end
	elseif dir == "l" then
		self.zoom_offS_edited = true
		if self.zoom_offS.c > 0 then
			if self.zoom_offS.c == self.col_size-27 then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "e", alpha = 1})
			end
			if not self.shifting or ignore_shift then
				self.zoom_offS.c = self.zoom_offS.c-1
			else
				self.zoom_offS.c = 0
			end
			if self.zoom_offS.c == 0 then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "w", alpha = 0})
			end
			update_zoom_board(self)
		end
	elseif dir == "r" then
		self.zoom_offS_edited = true
		if self.zoom_offS.c < self.col_size-27 then
			if self.zoom_offS.c == 0 then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "w", alpha = 1})
			end
			if not self.shifting or ignore_shift then
				self.zoom_offS.c = self.zoom_offS.c+1
			else
				self.zoom_offS.c = self.col_size-27
			end
			if self.zoom_offS.c == self.col_size-27 then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "e", alpha = 0})
			end
			update_zoom_board(self)
		end
	end
end

local function deflash(self)
	for r = 1, self.row_size do
		for c = 1, self.col_size do
			if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS+self.col_offS, r+1+self.mini_offS+self.row_offS) == 16 then
				tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS+self.col_offS, r+1+self.mini_offS+self.row_offS, self.board[r][c])
				if self.zoomed then 
					local colref = c+1-(self.zoom_offS.c)
					local rowref = r+1-(self.row_size-16+self.zoom_offS.r)
					if colref > 1 and colref < 29 and rowref > 1 and rowref < 18 then 
						tilemap.set_tile("/zoom#board-zoom", "layer1", colref, rowref, self.board[r][c])
					end
				end
			end
		end
	end
	self.flashing = false
end

local function point_in_list(point, list)
	for i,l in ipairs(list) do
		if point.r == l.r and point.c == l.c then
			return true
		end
	end
	return false
end

local function lose_game(self, mines)
	save_game(self)
	msg.post("/gui#minefinder", "full_board_anim", {anim = true})
	if self.zoomed then
		msg.post("/gui-zoom#zoom", "set_ticking", {ticking = false})
		msg.post("/gui-zoom#zoom", "zoom_click")
		self.spare = "boom"
		self.tile_size = 4
	else
		msg.post("/gui#minefinder", "set_ticking", {ticking = false})
	end
	for i,m in ipairs(mines) do
		tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", m.c+1, m.r+1, self.board[m.r-self.row_offS-self.mini_offS][m.c-self.col_offS-self.mini_offS])
	end
	-- print("you lose!")
	self.playing = false
	if self.anims["explosion"] then
		for i,m in ipairs(mines) do
			local props = {wick = true, mini = self.mini_offS}
			local id = factory.create("#explosion-factory", vmath.vector3(m.c*(6*self.tile_size)+3*self.tile_size, m.r*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
			msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "boom"})
			self.full_board_anim = true
		end
	end

	self.mine_locs = {}
	for i = 1, self.row_size do
		for j = 1, self.col_size do
			if self.board[i][j] == 12 and not point_in_list({r = i+self.row_offS+self.mini_offS, c = j+self.col_offS+self.mini_offS}, mines) then
				if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", j+1+self.col_offS+self.mini_offS, i+1+self.row_offS+self.mini_offS) == 13 then
					table.insert(self.mine_locs, {i+self.row_offS+self.mini_offS, j+self.col_offS+self.mini_offS, true})
				else
					table.insert(self.mine_locs, {i+self.row_offS+self.mini_offS, j+self.col_offS+self.mini_offS, false})
				end
			end
		end
	end
	shuffle(self.mine_locs)

	if self.mini_offS == 1 then
		self.timer = 1
	else
		self.timer = 2
	end
	self.mine_i = 1
	if self.flashing then
		deflash(self)
	end
end





local function window_callback(self, event, data)
	if event == window.WINDOW_EVENT_RESIZED then
		l_data.screen_size.x, l_data.screen_size.y = data.width, data.height
	end
end


-- _    __    _    _    _____
--| |  |   \ | |  | |  |_   _|
--| |  | |\ \| |  | |    | |
--|_|  |_| \___|  |_|    |_|

go.property("light_theme", resource.tile_source("/main/minefinder-light.tilesource"))
go.property("dark_theme", resource.tile_source("/main/minefinder-dark.tilesource"))
go.property("midnight_theme", resource.tile_source("/main/minefinder-midnight.tilesource"))
go.property("light_theme_mini", resource.tile_source("/main/minefinder-mini-light.tilesource"))
go.property("dark_theme_mini", resource.tile_source("/main/minefinder-mini-dark.tilesource"))
go.property("midnight_theme_mini", resource.tile_source("/main/minefinder-mini-midnight.tilesource"))

function init(self)
	load_game(self)
	window.set_listener(window_callback)
	l_data.screen_size = {x = nil, y = nil}
	l_data.screen_ratio = {x = 1392, y = 864}
	l_data.screen_size.x, l_data.screen_size.y = window.get_size()
	
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	go.set("/anims", "position", vmath.vector3()) -- un-offset anims gui (offset for readability in main.collection)
	go.set("/graffiti", "position", vmath.vector3()) -- un-offset graffiti (hidden)
	go.set("/gui-zoom", "position", vmath.vector3()) -- un-offset anims gui (offset for readability in main.collection)
	self.anims = {flag_place = true, flag_remove = true, flag_correct = true, flag_incorrect = true, explosion = true, timer = true, ui = true, tileflip = true, flip_bg = false, faster_flip = true}
	self.anim_vars = {"flag_place", "flag_remove", "flag_correct", "flag_incorrect", "explosion", "timer", "tileflip", "ui", "flip_bg", "faster_flip"}
	msg.post(".", "setup")
	self.theme = self.theme or "dark"
	self.tilesources = {light = self.light_theme, dark = self.dark_theme, midnight = self.midnight_theme}
	self.tilesources_mini = {light = self.light_theme_mini, dark = self.dark_theme_mini, midnight = self.midnight_theme_mini}
	l_data.diff = 3 -- CHANGE HERE
	self.tile_size = 8
	self.hard_select = true -- basic large-corner select
	self.mini_select = false -- tiny select for large boards
	self.large_select = false -- difficulty selector
	self.visible_select = true -- false when off the board on higher difficulty
	self.covered_select = false -- true when touching advanced anims panel
	self.hide_select = false -- for hiding select while touching other objects
	self.tile_lit = false
	self.m_row_prev = 0
	self.m_col_prev = 0
	self.current_orb = nil
	self.board_size = 16
	self.mini_offS = 0
	self.more_anims = false
	self.instances = {}
	self.watch_t_flips = false
	self.zoom_offS = {r = 0, c = 0}
	self.scrollnum = 0
	
	go.set("/diff-selected", "position", vmath.vector3((19 + l_data.diff)*8+4, 8*8+4, 0.7))
	go.set("/zoom#board", "tile_source", self.tilesources[self.theme])
	go.set("/zoom#board-mini", "tile_source", self.tilesources_mini[self.theme])
	go.set("/diff-selected-temp", "position.z", -0.7)
	-- resource.set_texture(path, table, buffer)
	msg.post(".", "acquire_input_focus")
end



-- __    __    ____     _____
--|   \/   |  /  __\   /  ___|
--| |\__/| |  \__  \  |  |_  \
--|_|    |_|  \____/   \_____/

function on_message(self, message_id, message, sender)
	if message_id == hash("setup") then
		math.randomseed(socket.gettime())
		-- math.randomseed(0)
		
		self.board = {}
		if not l_data.swap_board then
			set_props(self)
		end
		self.row_offS = math.floor((self.board_size-self.row_size)/2)
		self.col_offS = math.floor((self.board_size-self.col_size)/2)
		if self.row_size%2 == 1 then
			self.row_odd_offS = 1
		else
			self.row_odd_offS = 0
		end
		if self.col_size%2 == 1 then
			self.col_odd_offS = 1
		else
			self.col_odd_offS = 0
			
		end
		self.playing = true
		self.wrong_flags = nil
		self.to_flip = {}
		self.timer = nil
		self.anim_skip = false
		self.resettable = true
		self.game_started = false
		self.zoom_offS = {r = 0, c = 0}
		self.zoom_offS_edited = false

		if self.new_diff and not l_data.swap_board and not message.mines_only then
			self.watch_t_flips = true
			self.board_layout = {}
			for i = 1, self.board_size do
				table.insert(self.board_layout, {})
				for j = 1, self.board_size do
					self.board_layout[i][j] = 0
				end
			end

			-- (moveRow_t >= self.row_size+1+self.mini_offS+self.row_offS or moveCol_t >= self.col_size+1+self.mini_offS+self.col_offS or moveRow_t <= self.row_offS+self.mini_offS or moveCol_t <= self.col_offS+self.mini_offS)
			for i = self.row_offS+1, self.row_size+self.row_offS do 
				for j = self.col_offS+1, self.col_size+self.col_offS do
					self.board_layout[i][j] = 1
				end
			end

			if tilemap.get_tile("/zoom#board", "layer1", 9, 9) ~= 20 and (self.row_size > 16 or self.col_size > 16) then --regular to mini swap
				self.playing = false
				for r = 1, 16 do
					for c = 1, 16 do
						if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) ~= 14 then
							if self.anims["tileflip"] then
								local props = {final = 0, tile = tilemap.get_tile("/zoom#board", "layer1", c+1, r+1), mini = 0, tile_size = 8, theme_id = theme_to_id(self.theme), removing = 2}
								local id = factory.create("#flip-factory", vmath.vector3(c*48+24, r*48+24, 0.5), nil, props)
								msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
							else
								tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, 20)
							end
						else
							tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, 20)
						end
					end
				end
				l_data.swap_board = true
				if self.anims["tileflip"] then
					self.swap_board_timer = 0.2
				else
					self.swap_board_timer = 0
				end
			elseif tilemap.get_tile("/zoom#board-mini", "layer1", 18, 18) ~= 14 and (self.row_size <= 16 and self.col_size <= 16) then --mini to regular swap
				self.playing = false
				for r = 1, 32 do
					for c = 1, 32 do
						if tilemap.get_tile("/zoom#board-mini", "layer1", c+2, r+2) ~= 14 then
							if self.anims["tileflip"] then
								local props = {final = 0, tile = tilemap.get_tile("/zoom#board-mini", "layer1", c+2, r+2), mini = 1, tile_size = 4, theme_id = theme_to_id(self.theme), removing = 1}
								local id = factory.create("#flip-factory", vmath.vector3((c+1)*24+12, (r+1)*24+12, 0.5), nil, props)
								msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
							else
								tilemap.set_tile("/zoom#board-mini", "layer1", c+2, r+2, 14)
							end
						else
							tilemap.set_tile("/zoom#board-mini", "layer1", c+2, r+2, 14)
						end
					end
				end
				l_data.swap_board = true
				if self.anims["tileflip"] then
					self.swap_board_timer = 0.1
				else
					self.swap_board_timer = 0
				end
			else--
				for r = 1, self.board_size do
					for c = 1, self.board_size do
						if self.board_layout[r][c] == 0 and tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS) ~= 14 then
							if self.anims["tileflip"] then
								local props = {final = 0, tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS), mini = self.mini_offS, tile_size = self.tile_size, theme_id = theme_to_id(self.theme), removing = 1, set_playing = 1}
								local id = factory.create("#flip-factory", vmath.vector3((c+self.mini_offS)*(6*self.tile_size)+3*self.tile_size, (r+self.mini_offS)*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
								msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
							else
								tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS, 14)
							end
						elseif self.board_layout[r][c] == 1 and tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS) ~= 11 then
							if self.anims["tileflip"] then
								local props = {final = 0, tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS), mini = self.mini_offS, tile_size = self.tile_size, theme_id = theme_to_id(self.theme), set_playing = 1}
								local id = factory.create("#flip-factory", vmath.vector3((c+self.mini_offS)*(6*self.tile_size)+3*self.tile_size, (r+self.mini_offS)*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
								msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
							else
								tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS, 11)	
							end
						end
					end
				end
				self.board_layout = nil
			end--
			self.new_diff = false
		end
	elseif message_id == hash("reset") then 
		if not l_data.snake then
			if self.resettable then
				if self.tile_clicked ~= nil then
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1, self.row_clicked+1, self.tile_clicked)
					if self.zoomed then
						local colref = self.col_clicked-(self.col_offS+self.zoom_offS.c)
						local rowref = self.row_clicked-(self.row_offS+self.row_size-16+self.zoom_offS.r)
						tilemap.set_tile("/zoom#board-zoom", "layer1", colref, rowref, self.tile_clicked)
					end
					if self.mines_dug_around then
						local index = 0
						for i = -1, 1 do
							for j = -1, 1 do
								if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1+i, self.row_clicked+1+j) == 16 then
									index = index+1
									tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1+i, self.row_clicked+1+j, self.mines_dug_around_list[index])
									if self.zoomed then
										tilemap.set_tile("/zoom#board-zoom", "layer1", self.col_clicked_true+1+i, self.row_clicked_true+1+j, self.mines_dug_around_list[index])
									end
								end
							end
						end
					end
					self.mines_dug_around_list = nil
					self.tile_clicked = nil
					self.row_clicked = nil
					self.col_clicked = nil
					self.row_clicked_true = nil
					self.col_clicked_true = nil
					self.tile_action = nil
				end
				if self.game_started then
					msg.post(".", "purge_instances")
				end
				self.mine_locs = nil
				self.mine_i = nil
				self.correct_flags = nil
				self.win_flag_timer = nil
				self.timer = 0
				self.playing = false
				self.wrong_flags = nil
				msg.post("/gui#minefinder", "reset", {mines = self.num_mines})
				self.resettable = false
				
				if not message.change_diff then
					for r = self.row_size+self.row_offS, 1+self.row_offS, -1 do
						for c = 1+self.col_offS, self.col_size+self.col_offS do
							if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS) ~= 11 or self.anims["flip_bg"] then
								table.insert(self.to_flip, {r+self.mini_offS, c+self.mini_offS})
							end
						end
					end
				end
				if #self.to_flip < 1 then
					msg.post(".", "setup")
				end
			elseif #self.to_flip > 0 then
				self.anim_skip = true
			end
		else
			self.tile_size = 8
			self.snake_set = true
			l_data.snake_alive = false
			msg.post(".", "snake_setup")
		end
	elseif message_id == hash("add_url") then
		table.insert(self.instances, {message.hash, message.type})
	elseif message_id == hash("remove_url") then
		for i, k in ipairs(self.instances) do
			if k[1].path == message.hash.path then
				table.remove(self.instances, i)
				break
			end
			if i == #self.instances then
				print("nothing removed (" .. tostring(message.hash) .. ")")
			end
		end
		if message.hash.path == self.food_url then
			self.food_url = nil
		end
	elseif message_id == hash("purge_instances") then
		local spared_instances = {}
		while #self.instances > #spared_instances do
			for i, k in ipairs(self.instances) do
				if not (self.spare and self.spare == k[2]) then
					msg.post(k[1], "kill")
					table.remove(self.instances, i)
				else
					table.insert(spared_instances, table.remove(self.instances, i))
				end
			end
		end
		for i, k in ipairs(spared_instances) do
			table.insert(self.instances, spared_instances[i])
		end
		if self.spare then
			self.spare = nil
		end
		if self.food_url then
			self.food_url = nil
		end
	elseif message_id == hash("set_anims") then
		if message.anims == false then
			msg.post(".", "purge_instances")
			if self.resettable == false and #self.to_flip == 0 then
				msg.post(".", "setup")
			end
			if l_data.snake and l_data.snake_alive then
				tilemap.set_tile("/zoom#board", "layer1", self.food.x, self.food.y, 12)
				for i, s in ipairs(self.snake_segments) do
					if i < #self.snake_segments then
						tilemap.set_tile("/zoom#board", "layer1", s.x, s.y, 3)
					end
				end
			end
		end
		if message.anims == true or message.anims == false then
			for i = 1, 8 do
				self.anims[self.anim_vars[i]] = message.anims
			end
		end
	elseif message_id == hash("update_anims") then
		-- WIP - purge specific instances
		self.anims[self.anim_vars[message.index]] = message.setting
	elseif message_id == hash("remove_orb") then
		self.current_orb = "done"
	elseif message_id == hash("set_theme") then
		self.theme = message.theme
		go.set("/zoom#board", "tile_source", self.tilesources[self.theme])
		go.set("/zoom#board-mini", "tile_source", self.tilesources_mini[self.theme])
		go.set("/zoom#board-zoom", "tile_source", self.tilesources[self.theme])
		local tilenum
		if self.theme == "light" then
			tilenum = 16
		elseif self.theme == "dark" then
			tilenum = 18
		else
			tilenum = 14
		end
		if not message.startup then
			msg.post(".", "flash", {tile = tilenum})
		else
			if self.theme == "dark" then
				sprite.play_flipbook("/light-switch", "light-switch1")
			elseif self.theme == "light" then
				sprite.play_flipbook("/light-switch", "light-switch5")
			elseif self.theme == "midnight" then
				sprite.play_flipbook("/light-switch", "midnight-switch-09")
			end
		end
	elseif message_id == hash("flash") then -- change theme flash
		self.playing = false

		if not l_data.snake then
			for r = 1, self.row_size do
				for c = 1, self.col_size do
					tilemap.set_tile("/zoom#flash"..self.mini_txt, "layer1", c+1+self.col_offS+self.mini_offS, r+1+self.row_offS+self.mini_offS, message.tile)
				end
			end
		else
			for r = 1, 16 do
				for c = 1, 16 do
					tilemap.set_tile("/zoom#flash", "layer1", c+1, r+1, message.tile)
				end
			end
		end

		self.flash_timer = 0.1
	elseif message_id == hash("replace_board") then -- turn flash off
		if not l_data.snake then
			for r = 1, self.row_size do 
				for c = 1, self.col_size do
					tilemap.set_tile("/zoom#flash"..self.mini_txt, "layer1", c+1+self.col_offS+self.mini_offS, r+1+self.row_offS+self.mini_offS, 20)
				end
			end
		else
			for r = 1, 16 do 
				for c = 1, 16 do
					tilemap.set_tile("/zoom#flash", "layer1", c+1, r+1, 20)
				end
			end
		end
		self.playing = true
		self.board_tiles = nil
		self.flash_timer = nil
	elseif message_id == hash("more_anims") then
		self.more_anims = message.shown
	elseif message_id == hash("set_diff") then
		l_data.diff = l_data.diff_temp
		l_data.diff_temp = nil
		go.set("/diff-selected", "position", vmath.vector3((19 + l_data.diff)*8+4, 8*8+4, 0.7))
		go.set("/diff-selected-temp", "position.z", -0.7)
	elseif message_id == hash("hide_select") then 
		if message.hid then
			sprite.set_constant("/selection", "tint", vmath.vector4(1, 1, 1, 0))
		else
			sprite.set_constant("/selection", "tint", vmath.vector4(1, 1, 1, 1))
			go.set("/selection", "position.z", 0.8)
		end
		self.hide_select = message.hid
		self.select_update = true
	elseif message_id == hash("editing_dimensions") then
		self.editing_dimensions = message.editing
	elseif message_id == hash("snake_setup") then
		msg.post(".", "purge_instances")
		for r = 2, 17 do
			for c = 2, 17 do
				tilemap.set_tile("/zoom#board", "layer1", r, c, 11)
			end
		end
		msg.post("/gui#minefinder", "setup_snake_score")

		self.snake_segments = {
			{x = 3, y = 9},
			{x = 4, y = 9},
			{x = 5, y = 9},
			{x = 6, y = 9}
		}
		
		self.snake_dir = {x = 1, y = 0}
		self.snake_speed = 0.0
		self.dirqueue = {}
		self.snake_score = 0
		self.snake_t = 0

		self.food = {x = 14, y = 9}
		tilemap.set_tile("/zoom#board", "layer1", self.food.x, self.food.y, 12)

		for i, s in ipairs(self.snake_segments) do
			if i <= #self.snake_segments then
				tilemap.set_tile("/zoom#board", "layer1", s.x, s.y, 3)
				-- print("set init snake 2")
			end
		end
		l_data.snake_alive = true
	elseif message_id == hash("zoom") then
		self.zoomed = message.zoom
		if self.row_size < 16 then
			self.zoom_offS.r = math.floor((16-self.row_size)/2)
		end
		if self.col_size < 27 then
			self.zoom_offS.c = math.floor(-1*(27-self.col_size)/2)
		end
		update_zoom_board(self, not message.zoom)
		if message.zoom then
			self.tile_size = 8
			sprite.set_constant("/zoom#smileys", "tint", vmath.vector4(1, 1, 1, 0))
			sprite.set_constant("/diff-selected", "tint", vmath.vector4(1, 1, 1, 0))
			sprite.set_constant("/diff-selected-temp", "tint", vmath.vector4(1, 1, 1, 0))
			sprite.set_constant("/light-switch", "tint", vmath.vector4(1, 1, 1, 0))
			sprite.set_constant("/anim-switch", "tint", vmath.vector4(1, 1, 1, 0))
			msg.post("/gui-zoom#zoom", "midnight_thm", {theme = (self.theme == "midnight")})
			if not self.zoom_offS_edited then
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "n", alpha = 0})
				msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "w", alpha = 0})
				if self.row_size > 16 then
					msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "s", alpha = 1})
				else
					msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "s", alpha = 0})
				end
				if self.col_size > 27 then
					msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "e", alpha = 1})
				else
					msg.post("/gui-zoom#zoom", "edit_arrows", {dir = "e", alpha = 0})
				end
			end
		else
			self.tile_size = 4
			go.set("/selection", "position.z", -0.8)
			sprite.set_constant("/zoom#smileys", "tint", vmath.vector4(1, 1, 1, 1))
			sprite.set_constant("/diff-selected", "tint", vmath.vector4(1, 1, 1, 1))
			sprite.set_constant("/diff-selected-temp", "tint", vmath.vector4(1, 1, 1, 1))
			sprite.set_constant("/light-switch", "tint", vmath.vector4(1, 1, 1, 1))
			sprite.set_constant("/anim-switch", "tint", vmath.vector4(1, 1, 1, 1))
		end
	elseif message_id == hash("arrow_press") then
		self.zoom_offS_edited = true
		if message.dir == "n" then
			self.zoom_offS.r = 0
		elseif message.dir == "e" then
			self.zoom_offS.c = self.col_size-27
		elseif message.dir == "s" then
			self.zoom_offS.r = -1*(self.row_size-16)
		elseif message.dir == "w" then
			self.zoom_offS.c = 0
		end
		update_zoom_board(self)
	end
end


-- _    __    _    ___     __ __    _____
--| |  |   \ | |  |  _ \  |  |  |  |_   _|
--| |  | |\ \| |  |  __/  |  |  |    | |
--|_|  |_| \___|  |_|      \___/     |_|

function on_input(self, action_id, action)
	local zoom = math.min(l_data.screen_size.x / l_data.screen_ratio.x, l_data.screen_size.y / l_data.screen_ratio.y)
	local projected_width = l_data.screen_size.x / zoom
	local projected_height = l_data.screen_size.y / zoom
	local xoffset = -(projected_width - l_data.screen_ratio.x) / 2
	local yoffset = -(projected_height - l_data.screen_ratio.y) / 2
	local mouse_x = (action.x / l_data.screen_ratio.x) * projected_width + xoffset
	local mouse_y = (action.y / l_data.screen_ratio.y) * projected_height + yoffset
	
	if not l_data.snake then
		if action_id == hash("shift") then
			if action.pressed then
				self.shifting = true
			elseif action.released then
				self.shifting = false
			end
		end	
		
		if (action_id == hash("touch") or action_id == hash("select") or (action_id == hash("select-key") and not self.shifting)) and action.pressed and self.playing and not self.editing_dimensions and (not self.watch_t_flips or count_t_flips(self) == 0) then
			local moveRow = math.floor(mouse_y/48) --gives the mouse tile for strictly 8x8 tiles
			local moveCol = math.floor(mouse_x/48)
			local moveRow_t = math.floor(mouse_y/(6*self.tile_size)) --gives the mouse tile for varying game tiles
			local moveCol_t = math.floor(mouse_x/(6*self.tile_size))
			if self.zoomed then
				moveRow_t = moveRow_t+1+self.row_offS+self.row_size-16+self.zoom_offS.r
				moveCol_t = moveCol_t+1+self.col_offS+self.zoom_offS.c
			end
			if (not self.zoomed and moveRow_t < self.row_size+1+self.mini_offS+self.row_offS and moveCol_t < self.col_size+1+self.mini_offS+self.col_offS and moveRow_t > self.row_offS+self.mini_offS and moveCol_t > self.col_offS+self.mini_offS) or (self.zoomed and moveCol > 0 and moveCol < 28 and moveRow > 0 and moveRow < 17 and (self.row_size > 15 or (moveRow < 17-(16-self.row_size)/2 and moveRow > (16-self.row_size)/2+self.row_size%2)) and (self.col_size > 26 or (moveCol < 28-(27-self.col_size)/2 and moveCol > (27-self.col_size)/2+(self.col_size+1)%2))) then  
				if not self.tile_clicked then
					self.tile_clicked = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1)
				end
				self.row_clicked = moveRow_t
				self.col_clicked = moveCol_t
				self.row_clicked_true = moveRow
				self.col_clicked_true = moveCol
				self.tile_action = action_id
				tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, 16)
				if self.zoomed then
					tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1, moveRow+1, 16)
				end
				if self.tile_clicked < 11 and action_id == hash("touch") and self.shifting then
					self.mines_dug_around_list = {}
					for i = -1, 1 do
						for j = -1, 1 do
							if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1+i, moveRow_t+1+j) == 11 and (i ~= 0 or j ~= 0) then
								self.mines_dug_around = true
								table.insert(self.mines_dug_around_list, tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1+i, moveRow_t+1+j))
								tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1+i, moveRow_t+1+j, 16)
								if self.zoomed then
									tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1+i, moveRow+1+j, 16)
								end
							end
						end
					end
				end
			end
		end
		
		if self.tile_clicked and (action_id == hash("touch") or action_id == hash("select") or (action_id == hash("select-key") and not self.shifting)) and action.released and self.playing then
			local moveRow = math.floor(mouse_y/48)
			local moveCol = math.floor(mouse_x/48)
			local moveRow_t = math.floor(mouse_y/(6*self.tile_size))
			local moveCol_t = math.floor(mouse_x/(6*self.tile_size))
			if self.zoomed then
				moveRow_t = moveRow_t+1+self.row_offS+self.row_size-16+self.zoom_offS.r
				moveCol_t = moveCol_t+1+self.col_offS+self.zoom_offS.c
			end

			if l_data.settings.tutorial then
				l_data.settings.tutorial = false
				msg.post("/gui#minefinder", "set_tutorial", {alpha = 0})
				msg.post("/settings#settings", "tutorial-off")
			end

			if (not self.zoomed and moveRow_t < self.row_size+1+self.mini_offS+self.row_offS and moveCol_t < self.col_size+1+self.mini_offS+self.col_offS and moveRow_t > self.row_offS+self.mini_offS and moveCol_t > self.col_offS+self.mini_offS) or (self.zoomed and moveCol > 0 and moveCol < 28 and moveRow > 0 and moveRow < 17 and (self.row_size > 15 or (moveRow < 17-(16-self.row_size)/2 and moveRow > (16-self.row_size)/2+self.row_size%2)) and (self.col_size > 26 or (moveCol < 28-(27-self.col_size)/2 and moveCol > (27-self.col_size)/2+(self.col_size+1)%2))) then  
				if not self.board[1] then --first move
					self.game_started = true
					self.board = {}
					for i = 1, self.row_size do
						table.insert(self.board, {})
					end

					for r = 1, self.row_size do -- setting the board up
						for c = 1, self.col_size do
							self.board[r][c] = 0
						end
					end

					local row_1st = moveRow_t-self.row_offS-self.mini_offS
					local col_1st = moveCol_t-self.col_offS-self.mini_offS
					self.board[row_1st][col_1st] = 14


					local mine_list = {} --list of all spots outside the 8 around the starting tile
					local center_mines = {} -- the 8 tiles around the starting tile
					for r = 1, self.row_size do
						for c = 1, self.col_size do
							if not (math.abs(row_1st-r) <= 1 and math.abs(col_1st-c) <= 1) then
								table.insert(mine_list, {r, c})
							elseif row_1st-r ~= 0 or col_1st-c ~= 0 then
								table.insert(center_mines, {r, c})
							end
						end
					end

					shuffle(mine_list)
					shuffle(center_mines)

					
					local count = 1
					while count <= self.num_mines do -- adding mines
						local tile 
						if #mine_list > 0 then
							tile = table.remove(mine_list, 1)
						else
							tile = table.remove(center_mines, 1)
						end
						
						local randRow = tile[1]
						local randCol = tile[2]
						self.board[randRow][randCol] = 12
						count = count + 1
					end

					
					self.board[row_1st][col_1st] = 0

					for r = 1, self.row_size do -- setting numbers
						for c = 1, self.col_size do
							if self.board[r][c] == 0 then
								self.board[r][c] = mines_around(self, r, c) + 1
							end
						end
					end

					if self.board[row_1st][col_1st] == 1 then
						show_block(self, moveRow_t, moveCol_t)
					else
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
						if self.zoomed then
							tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1, moveRow+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
						end
					end
					self.flashing = true
					self.timer = 0.1
					if self.zoomed then
						msg.post("/gui-zoom#zoom", "set_ticking", {ticking = true})
					else
						msg.post("/gui#minefinder", "set_ticking", {ticking = true})
					end
					
				else --NOT first move
					if self.tile_clicked == 13 then -- remove flag
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, 11)
						if self.zoomed then
							tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1, moveRow+1, 11)
						end
						if self.anims["flag_remove"] then
							local props = {type = 2, theme_id = theme_to_id(self.theme)}
							local id
							if not self.zoomed then
								id = factory.create("#flag-factory", vmath.vector3(moveCol_t*6*self.tile_size+self.tile_size*3, moveRow_t*6*self.tile_size+self.tile_size*3, 0.5), nil, props)
							else
								id = factory.create("#flag-factory", vmath.vector3(moveCol*6*self.tile_size+self.tile_size*3, moveRow*6*self.tile_size+self.tile_size*3, 0.65), nil, props)
							end
							msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flag-2"})
						end
					elseif (action_id == hash("select") or (action_id == hash("select-key") and not self.shifting) or (action_id == hash("touch") and self.shifting)) and self.tile_clicked == 11 then -- place flag
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, 13)
						if self.zoomed then
							tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1, moveRow+1, 13)
						end
						if self.anims["flag_place"] then
							local props
							local id
							if not self.zoomed then
								props = {type = 1-self.mini_offS, theme_id = theme_to_id(self.theme)}
								id = factory.create("#flag-factory", vmath.vector3(moveCol_t*(6*self.tile_size)+3*self.tile_size, moveRow_t*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
							else
								props = {type = 1, theme_id = theme_to_id(self.theme)}
								id = factory.create("#flag-factory", vmath.vector3(moveCol*(6*self.tile_size)+3*self.tile_size, moveRow*(6*self.tile_size)+3*self.tile_size, 0.65), nil, props)
							end
							msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flag-1"})
						end
					elseif self.tile_clicked > 10 then-- flip tile
						if self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS] == 1 then -- reveal block
							show_block(self, moveRow_t, moveCol_t)
							self.flashing = true
							self.timer = 0.1
						elseif self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS] == 12 then -- flip mine
							lose_game(self, {{r = moveRow_t, c = moveCol_t}})
						else -- digging a tile
							tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
							if self.zoomed then
								tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1, moveRow+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
							end
						end
					elseif (action_id == hash("touch") and self.shifting) and self.tile_clicked < 11 then --dig tiles around tile
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
						if self.zoomed then
							tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1, moveRow+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
						end
						local dug_mine = nil
						self.mines_dug_around = false
						for i = -1, 1 do
							for j = -1, 1 do
								if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1+i, moveRow_t+1+j) == 16 then
									if self.board[moveRow_t+j-self.row_offS-self.mini_offS][moveCol_t+i-self.col_offS-self.mini_offS] == 1 then
										show_block(self, moveRow_t+j, moveCol_t+i)
										self.flashing = true
										self.timer = 0.1
									elseif self.board[moveRow_t+j-self.row_offS-self.mini_offS][moveCol_t+i-self.col_offS-self.mini_offS] == 12 then
										if not dug_mine then
											dug_mine = {}
										end
										table.insert(dug_mine, {r = moveRow_t+j, c = moveCol_t+i})
									else
										tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1+i, moveRow_t+1+j, self.board[moveRow_t+j-self.row_offS-self.mini_offS][moveCol_t+i-self.col_offS-self.mini_offS])
										if self.zoomed then
											tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1+i, moveRow+1+j, self.board[moveRow_t+j-self.row_offS-self.mini_offS][moveCol_t+i-self.col_offS-self.mini_offS])
										end
									end
								end
							end
						end

						if dug_mine then
							lose_game(self, dug_mine)
						end
					else
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
						if self.zoomed then
							tilemap.set_tile("/zoom#board-zoom", "layer1", moveCol+1, moveRow+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
						end
					end
				end -- end of not first move
				
				local flag_count = 0
				local won_game = true 
				local tile
				for r = 1, self.row_size do
					for c = 1, self.col_size do
						tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.col_offS+self.mini_offS, r+1+self.row_offS+self.mini_offS)
						if tile == 13 then
							flag_count = flag_count + 1
						end
						if won_game and tile > 9 and tile ~= 16 and self.board[r][c] < 10 then
							won_game = false
						end
					end
				end

				if not self.zoomed then
					msg.post("/gui#minefinder", "set_flags", {num = self.num_mines-flag_count})
				else
					msg.post("/gui-zoom#zoom", "set_flags", {num = self.num_mines-flag_count})
				end
				
				if won_game then
					save_game(self)
					if self.zoomed then
						msg.post("/gui-zoom#zoom", "set_ticking", {ticking = false})
						msg.post("/gui-zoom#zoom", "set_hs")
						msg.post("/gui-zoom#zoom", "zoom_click")
						self.tile_size = 4
						self.spare = "flag-1"
					else
						msg.post("/gui#minefinder", "set_ticking", {ticking = false})
						msg.post("/gui#minefinder", "set_hs")
					end
					-- print("you win!")
					self.playing = false
					self.win_flag_timer = 0
					self.correct_flags = {}

					for r = self.row_size+self.row_offS+self.mini_offS, self.row_offS+self.mini_offS, -1 do
						for c = self.col_offS+self.mini_offS, self.col_size+self.col_offS+self.mini_offS do
							if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1, r+1) == 11 then
								tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1, r+1, 13)
								if self.anims["flag_place"] then
									self.win_flag_timer = 0.3
									local props = {type = 1-self.mini_offS, theme_id = theme_to_id(self.theme)}
									local id = factory.create("#flag-factory", vmath.vector3(c*(6*self.tile_size)+3*self.tile_size, r*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
									msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flag-1"})
									if not self.full_board_anim then
										self.full_board_anim = true
										msg.post("/gui#minefinder", "full_board_anim", {anim = true})
									end
								end
							end
							if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1, r+1) == 13 then
								table.insert(self.correct_flags, {r, c})
							end
						end
					end
					msg.post("/gui#minefinder", "set_flags", {num = 0})
					self.win_flag_timer = self.win_flag_timer + 0.3
					if not self.anims["flag_correct"] then
						self.win_flag_timer = self.win_flag_timer + 1
					end
					
				end
			end
			self.mines_dug_around_list = nil
			self.tile_clicked = nil
			self.row_clicked = nil
			self.col_clicked = nil
			self.row_clicked_true = nil
			self.col_clicked_true = nil
			self.tile_action = nil
		end


		if self.zoomed then
			if action_id == hash("u-arr") and action.pressed then
				arrow_key_nav(self, "u")
			elseif action_id == hash("d-arr") and action.pressed then
				arrow_key_nav(self, "d")
			elseif action_id == hash("l-arr") and action.pressed then
				arrow_key_nav(self, "l")
			elseif action_id == hash("r-arr") and action.pressed then
				arrow_key_nav(self, "r")
			end
		end

		local moveRow = math.floor(mouse_y/(48))
		local moveCol = math.floor(mouse_x/(48))

		if (action_id == hash("scroll-up") or action_id == hash("scroll-down")) and self.zoomed and l_data.settings.scroll and moveCol > 0 and moveCol < 28 and moveRow > 0 and moveRow < 17 then
			self.scrollnum = self.scrollnum%60+1
			if self.scrollnum%(6-l_data.settings.scroll_slider) == 0 then
				if action_id == hash("scroll-up") and not self.shifting then
					arrow_key_nav(self, "u", true)
				elseif action_id== hash("scroll-down") and not self.shifting then
					arrow_key_nav(self, "d", true)
				elseif action_id == hash("scroll-up") and self.shifting then
					arrow_key_nav(self, "l", true)
				elseif action_id== hash("scroll-down") and self.shifting then
					arrow_key_nav(self, "r", true)
				end
			end
		end

		if action.pressed and action_id == hash("select-key") and self.shifting and (l_data.size_nums[1][l_data.diff] > 16 or l_data.size_nums[2][l_data.diff] > 16) and not self.full_board_anim and (not self.watch_t_flips or count_t_flips(self) == 0) then
			if self.zoomed then
				msg.post("/gui-zoom#zoom", "zoom_click")
			else
				msg.post("/gui#minefinder", "zoom_click")
			end
		end
	else
		if action_id == hash("u-arr") and action.pressed then
			table.insert(self.dirqueue, {x = 0, y = 1})
		elseif action_id == hash("d-arr") and action.pressed then
			table.insert(self.dirqueue, {x = 0, y = -1})
		elseif action_id == hash("l-arr") and action.pressed then
			table.insert(self.dirqueue, {x = -1, y = 0})
		elseif action_id == hash("r-arr") and action.pressed then
			table.insert(self.dirqueue, {x = 1, y = 0})
		end
		if self.snake_speed == 0 and (action_id == hash("u-arr") or action_id == hash("r-arr") or action_id == hash("d-arr")) then
			self.snake_speed = 10.0
			-- l_data.snake_alive = true
		end
	end

	
	--select stuff vvv
	
	local moveRow = math.floor(mouse_y/(48))
	local moveCol = math.floor(mouse_x/(48))
	local moveRow_t = math.floor(mouse_y/(6*self.tile_size))
	local moveCol_t = math.floor(mouse_x/(6*self.tile_size))
	if self.zoomed then
		moveRow_t = moveRow_t+1+self.row_offS+self.row_size-16+self.zoom_offS.r
		moveCol_t = moveCol_t+1+self.col_offS+self.zoom_offS.c
	end
	if self.row_clicked and (self.row_clicked ~= moveRow_t or self.col_clicked ~= moveCol_t) then --reset tile when mouse moved off
		if (self.tile_action == hash("select") or (self.tile_action == hash("select-key") and not self.shifting) or (self.tile_action == hash("touch") and self.shifting)) and self.game_started and self.tile_clicked == 11 or self.tile_clicked == 13 then 
			if self.tile_clicked == 11 then --flag
				tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1, self.row_clicked+1, 13)
				if self.zoomed then
					tilemap.set_tile("/zoom#board-zoom", "layer1", self.col_clicked_true+1, self.row_clicked_true+1, 13)
				end
				if self.anims["flag_place"] then
					local props
					local id
					if not self.zoomed then
						props = {type = 1-self.mini_offS, theme_id = theme_to_id(self.theme)}
						id = factory.create("#flag-factory", vmath.vector3(self.col_clicked*(6*self.tile_size)+3*self.tile_size, self.row_clicked*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
					else
						props = {type = 1, theme_id = theme_to_id(self.theme)}
						id = factory.create("#flag-factory", vmath.vector3(self.col_clicked_true*(6*self.tile_size)+3*self.tile_size, self.row_clicked_true*(6*self.tile_size)+3*self.tile_size, 0.65), nil, props)
					end
					msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flag-1"})
				end
			elseif self.tile_clicked == 13 then --deflag
				tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1, self.row_clicked+1, 11)
				if self.zoomed then
					tilemap.set_tile("/zoom#board-zoom", "layer1", self.col_clicked_true+1, self.row_clicked_true+1, 11)
				end
				if self.anims["flag_remove"] then
					local props = {type = 2, theme_id = theme_to_id(self.theme)}
					local id
					if not self.zoomed then
						id = factory.create("#flag-factory", vmath.vector3(self.col_clicked*6*self.tile_size+self.tile_size*3, self.row_clicked*6*self.tile_size+self.tile_size*3, 0.5), nil, props)
					else
						id = factory.create("#flag-factory", vmath.vector3(self.col_clicked_true*6*self.tile_size+self.tile_size*3, self.row_clicked_true*6*self.tile_size+self.tile_size*3, 0.65), nil, props)
					end
					msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flag-2"})
				end
			end
		else
			tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1, self.row_clicked+1, self.tile_clicked)
			if self.zoomed then
				local colref = self.col_clicked-(self.col_offS+self.zoom_offS.c)
				local rowref = self.row_clicked-(self.row_offS+self.row_size-16+self.zoom_offS.r)
				tilemap.set_tile("/zoom#board-zoom", "layer1", colref, rowref, self.tile_clicked)
			end
			if self.mines_dug_around then
				local index = 0
				for i = -1, 1 do
					for j = -1, 1 do
						if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1+i, self.row_clicked+1+j) == 16 then
							index = index+1
							tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1+i, self.row_clicked+1+j, self.mines_dug_around_list[index])
							if self.zoomed then
								tilemap.set_tile("/zoom#board-zoom", "layer1", self.col_clicked_true+1+i, self.row_clicked_true+1+j, self.mines_dug_around_list[index])
							end
						end
					end
				end
			end
		end

		self.mines_dug_around_list = nil
		self.tile_clicked = nil
		self.row_clicked = nil
		self.col_clicked = nil
		self.row_clicked_true = nil
		self.col_clicked_true = nil
		self.tile_action = nil
	end


	if not self.more_anims and not self.zoomed and moveCol > 19 and moveCol < 26 and math.floor(moveRow) == 8 then --change difficulty
		if not self.large_select then
			sprite.play_flipbook("/selection", "selection-large")
			self.large_select = true
		end
		if moveCol == 25 then
			if self.current_orb == nil and self.anims["ui"] then
				local id = factory.create("#orb-factory", vmath.vector3(25*48+24, 8*48+24, 0.9))
				self.current_orb = msg.url(nil, id, nil)
				msg.post(".", "add_url", {hash = self.current_orb})
			end
		elseif self.current_orb ~= nil then
			if self.current_orb ~= "done" then
				msg.post(self.current_orb, "erase")
			end
			self.current_orb = nil
		end
		if action_id == hash("touch") and action.pressed and not self.tile_lit then
			go.set("/brighten", "position", vmath.vector3(moveCol*8+4, moveRow*8+4, 1))
			self.tile_lit = true
		elseif action_id == hash("touch") and action.released and self.tile_lit then
			if moveCol - 19 ~= l_data.diff then
				l_data.diff_temp = moveCol - 19
				go.set("/diff-selected-temp", "position", vmath.vector3((19 + l_data.diff_temp)*8+4, 8*8+4, 0.7))
				go.set("/brighten", "position", vmath.vector3(20, 12, -0.5))
				msg.post("/gui#minefinder", "switch_hs")
				self.tile_lit = false
			else
				l_data.diff_temp = nil
				go.set("/diff-selected-temp", "position.z", -0.7)
				go.set("/brighten", "position", vmath.vector3(20, 12, -0.5))
				msg.post("/gui#minefinder", "switch_hs")
				self.tile_lit = false
			end
		elseif moveCol*8+4 ~= self.m_col_prev and self.tile_lit then
			go.set("/brighten", "position", vmath.vector3(20, 12, -0.5))
			self.tile_lit = false
		end
	else
		if self.current_orb ~= nil then
			if self.current_orb ~= "done" then
				msg.post(self.current_orb, "erase")
			end
			self.current_orb = nil
		end
		if self.tile_lit then
			go.set("/brighten", "position", vmath.vector3(20, 12, -0.5))
			self.tile_lit = false
		end
		if moveCol > 17 and (self.hard_select or self.large_select or self.mini_select) and not self.zoomed then
			sprite.play_flipbook("/selection", "selection-2")
			self.hard_select = false
			self.large_select = false
			self.tile_lit = false
			self.mini_select = false
		elseif self.tile_size == 4 and not self.mini_select and moveCol < 18 then
			sprite.play_flipbook("/selection", "selection-mini")
			self.mini_select = true
			self.hard_select = false
			self.large_select = false
			self.tile_lit = false
		elseif moveCol < 18 and (not self.hard_select or self.large_select) and self.tile_size == 8 then
			sprite.play_flipbook("/selection", "selection")
			self.hard_select = true
			self.large_select = false
			self.tile_lit = false
			self.mini_select = false
		end
	end

	local m_row
	local m_col

	if moveCol < 17 and self.tile_size ~= 8 then --position x/y of select
		m_row = moveRow_t*self.tile_size+self.tile_size/2
		m_col = moveCol_t*self.tile_size+self.tile_size/2
	else
		m_row = moveRow*8+4
		m_col = moveCol*8+4
	end

	local change_cover_var = true
	if self.more_anims and not self.covered_select and (mouse_y > 168 and mouse_y < 552) and (mouse_x > 888 and mouse_x < 1320) then --invisible select on more anims
		self.covered_select = true
	elseif self.covered_select and not ((mouse_y > 168 and mouse_y < 552) and (mouse_x > 888 and mouse_x < 1320)) then
		self.covered_select = false
	else
		change_cover_var = false
	end


	if self.covered_select or self.hide_select then
		go.set("/selection", "position", vmath.vector3(m_col, m_row, -0.8))
	elseif self.m_row_prev ~= m_row or self.m_col_prev ~= m_col or change_cover_var or self.select_update then
		if moveRow < 0 or moveRow > 17 or moveCol < 0 or moveCol > 28 then
			if self.select_update then
				self.select_update = nil
			end
			if self.visible_select then
				sprite.set_constant("/selection", "tint", vmath.vector4(1, 1, 1, 0))
				self.visible_select = false
			end
		elseif not self.visible_select then
			sprite.set_constant("/selection", "tint", vmath.vector4(1, 1, 1, 1))
			self.visible_select = true
		end

		local z_pos = 0.8
		if self.mini_offS == 1 and self.mini_select and (moveRow_t >= self.row_size+1+self.mini_offS+self.row_offS or moveCol_t >= self.col_size+1+self.mini_offS+self.col_offS or moveRow_t <= self.row_offS+self.mini_offS or moveCol_t <= self.col_offS+self.mini_offS) then
			z_pos = -0.8
		end
		-- go.set("/diff-selected", "position", vmath.vector3(moveCol*8+4, moveRow*8+4, 0.8))
		go.set("/selection", "position", vmath.vector3(m_col, m_row, z_pos))
	end

	self.m_row_prev = m_row
	self.m_col_prev = m_col
	

	if action_id == hash("debug") and action.pressed then
		save_game(self)
	end

	if action_id == hash("debug2") and action.pressed then
		print(l_data.settings.tutorial)
	end
end



-- __ __    ___     ___       ___     _____    _____
--|  |  |  |  _ \  |    \    /   \   |_   _|  |  ___|
--|  |  |  |  __/  |  |  |  | /_\ |    | |    |  __|
-- \___/   |_|     |____/   |_| |_|    |_|    |_____|

function update(self, dt) --checkpoint
	if not l_data.snake then
		if self.full_board_anim and #self.instances == 0 then
			self.full_board_anim = false
			msg.post("/gui#minefinder", "full_board_anim", {anim = false})
		end
		
		-- print(self.timer, self.board[1], #self.to_flip)
		if self.timer and (self.board[1] or #self.to_flip > 0) then
			while (self.timer <= 0 or (self.anims["timer"] == false and not self.flashing) or self.anim_skip == true) and (self.flashing or (self.mine_locs and self.mine_i <= #self.mine_locs) or #self.to_flip > 0) do
				-- print("acting")
				-- tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow][moveCol])
				if self.flashing then
					deflash(self)
				elseif #self.to_flip > 0 then
					if self.anims["tileflip"] then
						if #self.to_flip == 1 then
							if not self.full_board_anim then
								self.full_board_anim = true
								msg.post("/gui#minefinder", "full_board_anim", {anim = true})
							end
							local props = {final = 1, tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1), mini = self.mini_offS, tile_size = self.tile_size, theme_id = theme_to_id(self.theme)}
							local id = factory.create("#flip-factory", vmath.vector3(self.to_flip[1][2]*(6*self.tile_size)+3*self.tile_size, self.to_flip[1][1]*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
							msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
						else
							if not self.full_board_anim then
								self.full_board_anim = true
								msg.post("/gui#minefinder", "full_board_anim", {anim = true})
							end
							local props = {final = 0, tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1), mini = self.mini_offS, tile_size = self.tile_size, theme_id = theme_to_id(self.theme)}
							local id = factory.create("#flip-factory", vmath.vector3(self.to_flip[1][2]*(6*self.tile_size)+3*self.tile_size, self.to_flip[1][1]*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
							msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
						end
					else
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1, 11)
					end
					if self.anims["faster_flip"] then
						self.timer = 0.01
					else
						self.timer = 0.02
					end
					if #self.to_flip == 1 and self.anims["tileflip"] == false then
						msg.post(".", "setup")
					end
					table.remove(self.to_flip, 1)
				else
					local mineRow = self.mine_locs[self.mine_i][1]
					local mineCol = self.mine_locs[self.mine_i][2]
					if not self.full_board_anim then
						self.full_board_anim = true
						msg.post("/gui#minefinder", "full_board_anim", {anim = true})
					end
					if self.mine_locs[self.mine_i][3] then
						if self.anims["flag_correct"] then
							local props = {type = 3, theme_id = theme_to_id(self.theme)}
							local id = factory.create("#flag-factory", vmath.vector3(mineCol*(6*self.tile_size)+3*self.tile_size, mineRow*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
							msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flag-3"})
						end
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", mineCol+1, mineRow+1, 17)
					else
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", mineCol+1, mineRow+1, self.board[mineRow-self.row_offS-self.mini_offS][mineCol-self.col_offS-self.mini_offS])
						if self.anims["explosion"] then
							local props = {wick = false, mini = self.mini_offS}
							local id = factory.create("#explosion-factory", vmath.vector3(mineCol*(6*self.tile_size)+3*self.tile_size, mineRow*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
							msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "boom"})
						end
					end

					if self.mini_offS == 0 then
						self.timer = 1/self.mine_i
					else
						self.timer = 0.5/self.mine_i
					end
					
					if self.mine_i == #self.mine_locs then
						self.wrong_flags = {}
						self.mine_i = 1000
						self.flag_i = 1	
						for r = self.row_size+self.row_offS+self.mini_offS, 1+self.row_offS+self.mini_offS, -1 do
							for c = 1+self.col_offS, self.col_size+self.col_offS do
								if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1, r+1) == 13 then
									table.insert(self.wrong_flags, {r, c})
								end
							end
						end

						-- shuffle(self.wrong_flags) --makes wrong flags show in random order
						self.timer = 2.5
					end
					self.mine_i = self.mine_i + 1
				end
			end
			while (self.timer <= 0 or self.anims["timer"] == false or self.anim_skip == true) and self.wrong_flags and self.flag_i <= #self.wrong_flags do
				local flagRow = self.wrong_flags[self.flag_i][1]
				local flagCol = self.wrong_flags[self.flag_i][2]
				if self.anims["flag_incorrect"] then
					local props = {type = 4 + self.mini_offS, theme_id = theme_to_id(self.theme)}
					local id = factory.create("#flag-factory", vmath.vector3(flagCol*(6*self.tile_size)+3*self.tile_size, flagRow*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
					msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flag-4"})
				end
				self.timer = 1
				self.flag_i = self.flag_i + 1
			end
			if (self.board[1] or #self.to_flip > 0 or self.board_tiles) and self.flashing or (self.mine_locs and self.mine_i <= #self.mine_locs) or (self.wrong_flags and self.flag_i <= #self.wrong_flags) or #self.to_flip > 0 or self.board_tiles then
				self.timer = self.timer - dt
			else 
				self.timer = nil
			end
		end		

		if self.win_flag_timer then
			while self.win_flag_timer <= 0 and self.correct_flags and #self.correct_flags >= 0 do
				if #self.correct_flags == 0 then
					self.correct_flags = nil
				else
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.correct_flags[1][2]+1, self.correct_flags[1][1]+1, 17)
					if self.anims["flag_correct"] then
						local props = {type = 3, theme_id = theme_to_id(self.theme)}
						local id = factory.create("#flag-factory", vmath.vector3(self.correct_flags[1][2]*(6*self.tile_size)+3*self.tile_size, self.correct_flags[1][1]*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
						msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flag-3"})
						if not self.full_board_anim then
							self.full_board_anim = true
							msg.post("/gui#minefinder", "full_board_anim", {anim = true})
						end
						if self.anims["timer"] then
							self.win_flag_timer = 0.05
						end
					end
					table.remove(self.correct_flags, 1)
				end
			end
			if self.win_flag_timer >= 0 then
				self.win_flag_timer = self.win_flag_timer - dt
			else
				self.win_flag_timer = nil
			end
		end

		if self.swap_board_timer then
			if self.swap_board_timer <= 0 and l_data.swap_board then
				if self.mini_offS == 0 then
					for r = 1, 16 do
						for c = 1, 16 do
							tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, 14)	
						end
					end
				end
				for r = 1, self.board_size do--
					for c = 1, self.board_size do
						if self.board_layout[r][c] == 0 and tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS) ~= 14 then
							if self.anims["tileflip"] then
								local props = {final = 0, tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS), mini = self.mini_offS, tile_size = self.tile_size, theme_id = theme_to_id(self.theme), removing = 1}
								local id = factory.create("#flip-factory", vmath.vector3((c+self.mini_offS)*(6*self.tile_size)+3*self.tile_size, (r+self.mini_offS)*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
								msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
							else
								tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS, 14)
							end
						elseif self.board_layout[r][c] == 1 and tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS) ~= 11 then
							if self.anims["tileflip"] then
								local props = {final = 0, tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS), mini = self.mini_offS, tile_size = self.tile_size, theme_id = theme_to_id(self.theme)}
								local id = factory.create("#flip-factory", vmath.vector3((c+self.mini_offS)*(6*self.tile_size)+3*self.tile_size, (r+self.mini_offS)*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
								msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
							else
								tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS, 11)	
							end
						end
					end
				end--
				self.swap_board_timer = nil
				l_data.swap_board = false
				self.board_layout = nil
				self.playing = true
			else
				self.swap_board_timer = self.swap_board_timer - dt
			end
		end
	elseif self.snake_speed > 0 then
		self.snake_t = self.snake_t + dt
		
		if self.snake_t >= 1.0 / (self.snake_speed) and l_data.snake_alive then
			local newdir = table.remove(self.dirqueue, 1)
			if newdir then
				local opposite = newdir.x == -self.snake_dir.x or newdir.y == -self.snake_dir.y
				if not opposite then
					self.snake_dir = newdir
				end
			end

			local head = self.snake_segments[#self.snake_segments]
			local newhead = {x = head.x + self.snake_dir.x, y = head.y + self.snake_dir.y}

			table.insert(self.snake_segments, newhead)

			local tile = tilemap.get_tile("/zoom#board", "layer1", newhead.x, newhead.y)

			if (tile == 3 or (newhead.x == 18 or newhead.y == 18 or newhead.x == 1 or newhead.y == 1)) and (newhead.x ~= self.snake_segments[1].x or newhead.y ~= self.snake_segments[1].y) then
				l_data.snake_alive = false
			elseif tile == 12 or (newhead.x == self.food.x and newhead.y == self.food.y) then
				msg.post("/gui#minefinder", "update_snake_score")
				self.snake_score = self.snake_score + 1
				-- self.snake_speed = self.snake_speed + 0.5
				if self.food_url then
					msg.post(self.food_url, "kill")
					print("SPECOP")
					self.food_url = nil
				end
				put_food(self)
			else
				local tail = table.remove(self.snake_segments, 1)
				if self.anims["tileflip"] then
					local props = {final = 0, tile = 3, mini = 0, tile_size = 8, theme_id = theme_to_id(self.theme)}
					local id = factory.create("#flip-factory", vmath.vector3(tail.x*48-24, tail.y*48-24, 0.5), nil, props)
					msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
				else
					tilemap.set_tile("/zoom#board", "layer1", tail.x, tail.y, 11)
				end
			end

			if l_data.snake_alive then
				for i, s in ipairs(self.snake_segments) do
					if i == #self.snake_segments then
						if self.anims["tileflip"] then
							local props = {final = 0, tile = 3, mini = 0, tile_size = 8, theme_id = theme_to_id(self.theme), reverse = 1}
							local id = factory.create("#flip-factory", vmath.vector3(s.x*48-24, s.y*48-24, 0.5), nil, props)
							msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
						else
							tilemap.set_tile("/zoom#board", "layer1", s.x, s.y, 3)
						end
					elseif (i < #self.snake_segments-3 or not self.anims["tileflip"]) and tilemap.get_tile("/zoom#board", "layer1", s.x, s.y) ~= 3 then
						tilemap.set_tile("/zoom#board", "layer1", s.x, s.y, 3)
					end
				end
			else
				msg.post(".", "purge_instances")
				for i, s in ipairs(self.snake_segments) do
					if i < #self.snake_segments then
						if self.anims["tileflip"] then
							local props = {final = 0, tile = 4, mini = 0, tile_size = 8, theme_id = theme_to_id(self.theme), reverse = 1}
							local id = factory.create("#flip-factory", vmath.vector3(s.x*48-24, s.y*48-24, 0.5), nil, props)
							msg.post(".", "add_url", {hash = msg.url(nil, id, nil), type = "flip"})
							-- print(s.x, s.y)
						else
							tilemap.set_tile("/zoom#board", "layer1", s.x, s.y, 4)
						end
					end
				end
			end

			self.snake_t = 0
		end
	end

	if self.flash_timer then
		if self.flash_timer <= 0 then
			msg.post(".", "replace_board")
		else
			self.flash_timer = self.flash_timer - dt
		end
	end
end
