local function set_props(self)
	local mine_nums = {10, 14, 40, 100, 150}
	local size_nums = {{8, 10, 16, 16, 24}, {8, 10, 16, 30, 30}}
	self.num_mines = mine_nums[self.diff]
	self.row_size = size_nums[1][self.diff]
	self.col_size = size_nums[2][self.diff]
	msg.post("/gui#minefinder", "set_mines", {mines = self.num_mines})
end

local function shuffle(tbl)
	for i = #tbl, 2, -1 do
		local j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end

local function theme_to_id(theme)
	if theme == "dark" then
		print("dark")
		return 0
	else 
		print("light")
		return 1
	end
end

local function mines_around(self, row, col)
	local counter = 0
	for r = -1, 1 do
		for c = -1, 1 do
			if row+r > 0 and row+r < self.row_size+1 and col+c > 0 and col+c < self.col_size+1 then
				if self.board[row+r][col+c] == 12 then 
					counter = counter + 1
				elseif self.board[row+r][col+c] == 14 then
					return 11
				end
			end
		end
	end
	return counter
end

local function spaces_around(self, row, col)
	local counter = 0
	for r = -1, 1 do
		for c = -1, 1 do
			if tilemap.get_tile("/zoom#board", "layer1", col+c+1, row+r+1) ~= 14 then
				counter = counter + 1
			end
		end
	end

	return counter
end

local function show_block(self, row, col)
	tilemap.set_tile("/zoom#board", "layer1", col+1, row+1, self.board[row-self.row_offS][col-self.col_offS])
	for r = -1, 1 do
		for c = -1, 1 do
			if row+r > self.row_offS and row+r < self.row_size+1+self.row_offS and col+c > self.col_offS and col+c < self.col_size+1+self.col_offS then
				if self.board[row+r-self.row_offS][col+c-self.col_offS] == 1  and (tilemap.get_tile("/zoom#board", "layer1", col+c+1, row+r+1) == 11 or tilemap.get_tile("/zoom#board", "layer1", col+c+1, row+r+1) == 13) then
					show_block(self, row+r, col+c)
				else
					tilemap.set_tile("/zoom#board", "layer1", col+c+1, row+r+1, 16)
				end
			end
		end
	end
end

go.property("light_theme", resource.tile_source("/main/minefinder-light.tilesource"))
go.property("dark_theme", resource.tile_source("/main/minefinder-dark.tilesource"))

function init(self)
	self.anims = {flag_place = true, flag_remove = true, flag_correct = true, flag_incorrect = true, explosion = true, timer = true, ui = true, tileflip = true, flip_bg = false}
	msg.post(".", "setup")
	self.theme = "dark"
	self.tilesources = {light = self.light_theme, dark = self.dark_theme}
	self.diff = 3
	self.hard_select = true
	self.large_select = false
	self.tile_lit = false
	self.m_row_prev = 0
	self.m_col_prev = 0
	self.faster_flip = true
	self.current_orb = nil
	go.set("/diff-selected", "position", vmath.vector3((19 + self.diff)*8+4, 5*8+4, 0.7))
	go.set("/zoom#board", "tile_source", self.tilesources[self.theme])
	
	-- resource.set_texture(path, table, buffer)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("setup") then
		self.board = {}
		set_props(self)
		self.row_offS = (16-self.row_size)/2
		self.col_offS = (16-self.col_size)/2
		self.playing = true
		self.wrong_flags = nil
		self.to_flip = {}
		self.timer = nil
		self.anim_skip = false
		self.resettable = true
		if self.row_offS > 0 or self.col_offS > 0 then
			for r = 1, 16 do
				for c = 1, 16 do
					if (r <= self.row_offS or r > 16-self.row_offS) or (c <= self.col_offS or c > 16-self.col_offS) then
						tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, 14)
					end
				end
			end
		end

		if tilemap.get_tile("/zoom#board", "layer1", 2+self.col_offS, 9) ~= 11 or tilemap.get_tile("/zoom#board", "layer1", 9, 2+self.row_offS) ~= 11 then
			for r = 1, 16 do
				for c = 1, 16 do
					if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) ~= 11  then
						tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, 11)
					end
				end
			end
		end

		if self.row_size > 16 or self.col_size > 16 then
			for r = 1, 16 do
				for c = 1, 16 do
					tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, 20)
				end
			end
		end
		
		msg.post(".", "acquire_input_focus")
		math.randomseed(socket.gettime())
	elseif message_id == hash("reset") then --checkpoint
		if self.resettable then
			msg.post("/gui#minefinder", "purge_instances")
			self.mine_locs = nil
			self.mine_i = nil
			self.timer = 0
			self.playing = false
			msg.post("/gui#minefinder", "reset")
			self.resettable = false
			for r = self.row_size+self.row_offS, 1+self.row_offS, -1 do
				for c = 1+self.col_offS, self.col_size+self.col_offS do
					if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) ~= 11 or self.anims.flip_bg then
						table.insert(self.to_flip, {r, c})
					end
				end
			end
			if #self.to_flip < 1 then
				msg.post(".", "setup")
			end
		elseif #self.to_flip > 0 then
			self.anim_skip = true
		-- else
		-- 	print("no double reset")
		end
	elseif message_id == hash("set_anims") then
		if message.anims == false then
			msg.post("/gui#minefinder", "purge_instances")
			if self.resettable == false and #self.to_flip == 0 then
				msg.post(".", "setup")
			end
		end
		if message.anims == true or message.anims == false then
			self.anims = {flag_place = message.anims, flag_remove = message.anims, flag_correct = message.anims, flag_incorrect = message.anims, explosion = message.anims, timer = message.anims, ui = message.anims, tileflip = message.anims, flip_bg = self.anims.flip_bg}
						
			-- for i = 1, 8 do
			-- 	self.anims[i] = message.anims
			-- end
		end
	elseif message_id == hash("remove_orb") then
		self.current_orb = "done"
	end
end

function on_input(self, action_id, action)
	if (action_id == hash("touch") or action_id == hash("select")) and action.pressed and self.playing then
		local moveRow = math.floor(action.y/48)
		local moveCol = math.floor(action.x/48)
		if moveRow < self.row_size+1+self.row_offS and moveCol < self.col_size+1+self.col_offS and moveRow > self.row_offS and moveCol > self.col_offS then
			self.tile_clicked = tilemap.get_tile("/zoom#board", "layer1", moveCol+1, moveRow+1)
			self.row_clicked = moveRow
			self.col_clicked = moveCol
			tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 16)
		end
	end
	
	if self.tile_clicked and (action_id == hash("touch") or action_id == hash("select")) and action.released and self.playing then
		local moveRow = math.floor(action.y/48)
		local moveCol = math.floor(action.x/48)
		-- print(11-moveRow .. ", " .. moveCol)

		if moveRow < self.row_size+1+self.row_offS and moveCol < self.col_size+1+self.col_offS and moveRow > self.row_offS and moveCol > self.col_offS then
			if not self.board[1] then --first move
				self.board = {}
				for i = 1, self.row_size do
					table.insert(self.board, {})
				end

				for r = 1, self.row_size do -- setting the board up
					for c = 1, self.col_size do
						self.board[r][c] = 0
					end
				end

				self.board[moveRow-self.row_offS][moveCol-self.col_offS] = 14

				local count = 1
				while count <= self.num_mines do -- adding mines
					local randRow = math.random(1, self.row_size)
					local randCol = math.random(1, self.col_size)
					if mines_around(self, randRow, randCol) <= spaces_around(self, randRow, randCol)+1 and self.board[randRow][randCol] ~= 12 then
						-- print(randRow .. ", " .. randCol)
						self.board[randRow][randCol] = 12
						count = count + 1
					end
					-- print(mines_around(self, randRow, randCol) .. ", " .. spaces_around(self, randRow, randCol))
				end

				self.board[moveRow-self.row_offS][moveCol-self.col_offS] = 1

				for r = 1, self.row_size do
					for c = 1, self.col_size do
						if self.board[r][c] == 0 then
							self.board[r][c] = mines_around(self, r, c) + 1
						end
					end
				end

				show_block(self, moveRow, moveCol)
				self.flashing = true
				self.timer = 0.1
				msg.post("/gui#minefinder", "set_ticking", {ticking = true})
				
			else --NOT first move
				if self.tile_clicked == 13 then -- remove flag
					tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 11)
					if self.anims.flag_remove then
						local props = {type = 2, theme_id = theme_to_id(self.theme)}
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(moveCol*48+24, moveRow*48+24, 0.5), nil, props).."#flag"})
					end
				elseif action_id == hash("select") and self.tile_clicked == 11 then -- place flag
					tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 13)
					if self.anims.flag_place then
						local props = {type = 1, theme_id = theme_to_id(self.theme)}
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(moveCol*48+24, moveRow*48+24, 0.5), nil, props).."#flag"})
					end
				elseif self.tile_clicked > 10 then -- reveal block
					if self.board[moveRow-self.row_offS][moveCol-self.col_offS] == 1 then -- flip tile
						show_block(self, moveRow, moveCol)
						self.flashing = true
						self.timer = 0.1
						
					elseif self.board[moveRow-self.row_offS][moveCol-self.col_offS] == 12 then -- flip mine
						tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow-self.row_offS][moveCol-self.col_offS])
						msg.post("/gui#minefinder", "set_ticking", {ticking = false})
						print("you lose!")
						self.playing = false
						if self.anims.explosion then
							local props = {wick = true}
							msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#explosion-factory", vmath.vector3(moveCol*48+24, moveRow*48+24, 0.5), nil, props).."#explosion"})
						end
						
						self.mine_locs = {}
						for r = 1, self.row_size do
							for c = 1, self.col_size do
								if self.board[r][c] == 12 and not (r == moveRow-self.row_offS and c == moveCol-self.col_offS) then
									if tilemap.get_tile("/zoom#board", "layer1", c+1+self.col_offS, r+1+self.row_offS) == 13 then
										table.insert(self.mine_locs, {r+self.row_offS, c+self.col_offS, true})
									else
										table.insert(self.mine_locs, {r+self.row_offS, c+self.col_offS, false})
									end
								end
							end
						end
						shuffle(self.mine_locs)

						self.timer = 3
						self.mine_i = 1
					else -- digging a tile
						tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow-self.row_offS][moveCol-self.col_offS])
						
					end
				else
					tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow-self.row_offS][moveCol-self.col_offS])
				end
				local flag_count = 0
				local won_game = true
				for r = 1, self.row_size do
					for c = 1, self.col_size do
						if tilemap.get_tile("/zoom#board", "layer1", c+1+self.col_offS, r+1+self.row_offS) == 13 then
							flag_count = flag_count + 1
						end
						if won_game and tilemap.get_tile("/zoom#board", "layer1", c+1+self.col_offS, r+1+self.row_offS) > 9 and self.board[r][c] < 10 then
							won_game = false
						end
					end
				end
				
				msg.post("/gui#minefinder", "set_flags", {num = flag_count})

				if won_game then
					print("you win!")
					msg.post("/gui#minefinder", "set_ticking", {ticking = false})
					
					for r = self.row_offS, self.row_size+self.row_offS do
						for c = self.col_offS, self.col_size+self.col_offS do
							if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) == 11 then
								tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, 13)
								if self.anims.flag_place then
									local props = {type = 1, theme_id = theme_to_id(self.theme)}
									msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(c*48+24, r*48+24, 0.5), nil, props).."#flag"})
								end
							end
						end
					end
				end
			end
		end
		self.tile_clicked = nil
		self.row_clicked = nil
		self.col_clicked = nil
	end

	local moveRow = math.floor(action.y/48)
	local moveCol = math.floor(action.x/48)
	if self.row_clicked and (self.row_clicked ~= moveRow or self.col_clicked ~= moveCol) then
		tilemap.set_tile("/zoom#board", "layer1", self.col_clicked+1, self.row_clicked+1, self.tile_clicked)
		self.tile_clicked = nil
		self.row_clicked = nil
		self.col_clicked = nil
	end
	-- tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, 12)
	if moveCol > 19 and moveCol < 26 and moveRow == 5 then
		if not self.large_select then
			sprite.play_flipbook("/selection", "selection-large")
			self.large_select = true
		end
		if moveCol == 25 then
			if self.current_orb == nil then
				self.current_orb = "main:"..factory.create("#orb-factory", vmath.vector3(25*48+24, 5*48+24, 1)).."#orb"
				msg.post("/gui#minefinder", "add_url", {hash = self.current_orb})
			end
		elseif self.current_orb ~= nil then
			if self.current_orb ~= "done" then
				msg.post(self.current_orb, "kill")
			end
			self.current_orb = nil
		end
		if action_id == hash("touch") and action.pressed and not self.tile_lit then
			go.set("/brighten", "position", vmath.vector3(moveCol*8+4, moveRow*8+4, 1))
			self.tile_lit = true
		elseif action_id == hash("touch") and action.released and self.tile_lit then
			self.diff = moveCol - 19
			go.set("/diff-selected", "position", vmath.vector3((19 + self.diff)*8+4, 5*8+4, 0.7))			
			go.set("/brighten", "position", vmath.vector3(20, 12, 0))
			self.tile_lit = false
		end
	else
		if self.current_orb ~= nil then
			if self.current_orb ~= "done" then
				msg.post(self.current_orb, "kill")
			end
			self.current_orb = nil
		end
		if self.tile_lit then
			go.set("/brighten", "position", vmath.vector3(20, 12, 0))
			self.tile_lit = false
		end
		if moveCol > 17 and (self.hard_select or self.large_select) then
			sprite.play_flipbook("/selection", "frame-light")
			self.hard_select = false
			self.large_select = false
			self.tile_lit = false
		elseif moveCol < 18 and (not self.hard_select or self.large_select) then
			sprite.play_flipbook("/selection", "frame")
			self.hard_select = true
			self.large_select = false
			self.tile_lit = false
		end
	end
	
	local m_row = moveRow*8+4
	local m_col = moveCol*8+4

	if self.m_row_prev ~= m_row or self.m_col_prev ~= m_col then
		-- go.set("/diff-selected", "position", vmath.vector3(moveCol*8+4, moveRow*8+4, 0.8))
		go.set("/selection", "position", vmath.vector3(moveCol*8+4, moveRow*8+4, 0.8))
	end

	self.m_row_prev = moveRow*8+4
	self.m_col_prev = moveCol*8+4

	if action_id == hash("theme") and action.released then
		if self.theme == "light" then
			self.theme = "dark"
		else
			self.theme = "light"
		end
		go.set("/zoom#board", "tile_source", self.tilesources[self.theme])
	end
end


function update(self, dt) --checkpoint
	-- print(self.timer, self.board[1], #self.to_flip)
	if self.timer and (self.board[1] or #self.to_flip > 0) then
		while (self.timer <= 0 or self.anims.timer == false or self.anim_skip == true) and (self.flashing or (self.mine_locs and self.mine_i <= #self.mine_locs) or #self.to_flip > 0) do
			-- print("acting")
			-- tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow][moveCol])
			if self.flashing then
				for r = 1, self.row_size do
					for c = 1, self.col_size do
						if tilemap.get_tile("/zoom#board", "layer1", c+1+self.col_offS, r+1+self.row_offS) == 16 then
							tilemap.set_tile("/zoom#board", "layer1", c+1+self.col_offS, r+1+self.row_offS, self.board[r][c])
						end
					end
				end
				self.flashing = false
			elseif #self.to_flip > 0 then
				if self.anims.tileflip then
					if #self.to_flip == 1 then
						local props = {final = 1, tile = tilemap.get_tile("/zoom#board", "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1)}
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flip-factory", vmath.vector3(self.to_flip[1][2]*48+24, self.to_flip[1][1]*48+24, 0.5), nil, props).."#tileflip"})
						
					else
						local props = {final = 0, tile = tilemap.get_tile("/zoom#board", "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1)}
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flip-factory", vmath.vector3(self.to_flip[1][2]*48+24, self.to_flip[1][1]*48+24, 0.5), nil, props).."#tileflip"})
						
					end
				else
					tilemap.set_tile("/zoom#board", "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1, 11)
				end
				if self.faster_flip then
					self.timer = 0.01
				else
					self.timer = 0.02
				end
				if #self.to_flip == 1 and self.anims.tileflip == false then
					msg.post(".", "setup")
				end
				table.remove(self.to_flip, 1)
			else
				local mineRow = self.mine_locs[self.mine_i][1]
				local mineCol = self.mine_locs[self.mine_i][2]
				if self.mine_locs[self.mine_i][3] then
					if self.anims.flag_correct then
						local props = {type = 3, theme_id = theme_to_id(self.theme)}
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(mineCol*48+24, mineRow*48+24, 0.5), nil, props).."#flag"})
					end
					tilemap.set_tile("/zoom#board", "layer1", mineCol+1, mineRow+1, 17)
				else
					tilemap.set_tile("/zoom#board", "layer1", mineCol+1, mineRow+1, self.board[mineRow-self.row_offS][mineCol-self.col_offS])
					if self.anims.explosion then
						msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#explosion-factory", vmath.vector3(mineCol*48+24, mineRow*48+24, 0.5)).."#explosion"})
					end
				end

				self.timer = 1/self.mine_i
				
				if self.mine_i == #self.mine_locs then
					self.wrong_flags = {}
					self.mine_i = 1000
					self.flag_i = 1	
					for r = self.row_size+self.row_offS, 1+self.row_offS, -1 do
						for c = 1+self.col_offS, self.col_size+self.col_offS do
							if tilemap.get_tile("/zoom#board", "layer1", c+1, r+1) == 13 then
								table.insert(self.wrong_flags, {r, c})
							end
						end
					end
					-- shuffle(self.wrong_flags) --makes wrong flags show in random order
					self.timer = 2.5
				end
				self.mine_i = self.mine_i + 1
			end
		end
		while (self.timer <= 0 or self.anims.timer == false or self.anim_skip == true) and self.wrong_flags and self.flag_i <= #self.wrong_flags do
			local flagRow = self.wrong_flags[self.flag_i][1]
			local flagCol = self.wrong_flags[self.flag_i][2]
			if self.anims.flag_incorrect then
				local props = {type = 4, theme_id = theme_to_id(self.theme)}
				msg.post("/gui#minefinder", "add_url", {hash = "main:"..factory.create("#flag-factory", vmath.vector3(flagCol*48+24, flagRow*48+24, 0.5), nil, props).."#flag"})
			end
			self.timer = 1
			self.flag_i = self.flag_i + 1
		end
		if (self.board[1] or #self.to_flip > 0) and self.flashing or (self.mine_locs and self.mine_i <= #self.mine_locs) or (self.wrong_flags and self.flag_i <= #self.wrong_flags) or #self.to_flip > 0 then
			self.timer = self.timer - dt
			-- print("time down")
		else 
			self.timer = nil
			-- print("NIL!")
		end
		-- print("self.timing")
	end	
end