local l_data = require "main.leveldata"

local function set_props(self)
	self.num_mines = l_data.mine_nums[l_data.diff]
	self.row_size = l_data.size_nums[1][l_data.diff]
	self.col_size = l_data.size_nums[2][l_data.diff]
	self.row_size = 15
	self.col_size = 15
	if self.row_size > 16 or self.col_size > 16 then
		self.mini_txt = "-mini"
		-- self.tiny_select = true
		self.tile_size = 4
		self.board_size = 32
		self.mini_offS = 1
	else
		self.mini_txt = ""
		self.tiny_select = false
		self.tile_size = 8
		self.board_size = 16
		self.mini_offS = 0
	end
	
	msg.post("/gui#minefinder", "set_mines", {mines = self.num_mines})
	msg.post("/gui#minefinder", "reset", {mines = self.num_mines})
end

local function shuffle(tbl)
	for i = #tbl, 2, -1 do
		local j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end

local function theme_to_id(theme)
	if theme == "dark" then
		return 0
	else 
		return 1
	end
end

local function mines_around(self, row, col)
	local counter = 0
	for r = -1, 1 do
		for c = -1, 1 do
			if row+r > 0 and row+r < self.row_size+1 and col+c > 0 and col+c < self.col_size+1 then
				if self.board[row+r][col+c] == 12 then 
					counter = counter + 1
				elseif self.board[row+r][col+c] == 14 then
					return 11
				end
			end
		end
	end
	return counter
end

local function spaces_around(self, row, col)
	local counter = 0
	for r = -1, 1 do
		for c = -1, 1 do
			if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", col+c+1, row+r+1) ~= 14 then
				counter = counter + 1
			end
		end
	end

	return counter
end

local function show_block(self, row, col)
	tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", col+1, row+1, self.board[row-self.row_offS-self.mini_offS][col-self.col_offS-self.mini_offS])
	for r = -1, 1 do
		for c = -1, 1 do
			if row+r > self.row_offS+self.mini_offS and row+r < self.row_size+1+self.row_offS+self.mini_offS and col+c > self.col_offS+self.mini_offS and col+c < self.col_size+1+self.col_offS+self.mini_offS then
				if self.board[row+r-self.row_offS-self.mini_offS][col+c-self.col_offS-self.mini_offS] == 1  and (tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", col+c+1, row+r+1) == 11 or tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", col+c+1, row+r+1) == 13) then
					show_block(self, row+r, col+c)
				else
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", col+c+1, row+r+1, 16)
				end
			end
		end
	end
end



local function window_callback(self, event, data)
	if event == window.WINDOW_EVENT_RESIZED then
		self.screen_size.x, self.screen_size.y = data.width, data.height
	end
end


-- _    __    _    _    _____
--| |  |   \ | |  | |  |_   _|
--| |  | |\ \| |  | |    | |
--|_|  |_| \___|  |_|    |_|

go.property("light_theme", resource.tile_source("/main/minefinder-light.tilesource"))
go.property("dark_theme", resource.tile_source("/main/minefinder-dark.tilesource"))
go.property("light_theme_mini", resource.tile_source("/main/minefinder-mini-light.tilesource"))
go.property("dark_theme_mini", resource.tile_source("/main/minefinder-mini-dark.tilesource"))

function init(self)
	window.set_listener(window_callback)
	self.screen_size = {x = nil, y = nil}
	self.screen_ratio = {x = 1392, y = 864}
	self.screen_size.x, self.screen_size.y = window.get_size()
	
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	go.set("/anims", "position", vmath.vector3()) -- un-offset anims gui (offset for readability in main.collection
	self.anims = {flag_place = true, flag_remove = true, flag_correct = true, flag_incorrect = true, explosion = true, timer = true, ui = true, tileflip = true, flip_bg = false, faster_flip = true}
	self.anim_vars = {"flag_place", "flag_remove", "flag_correct", "flag_incorrect", "explosion", "timer", "tileflip", "ui", "flip_bg", "faster_flip"}
	msg.post(".", "setup")
	self.theme = "dark"
	self.tilesources = {light = self.light_theme, dark = self.dark_theme}
	self.tilesources_mini = {light = self.light_theme_mini, dark = self.dark_theme_mini}
	l_data.diff = 3 -- CHANGE HERE
	self.tile_size = 8
	self.hard_select = true -- basic large-corner select
	self.mini_select = false -- tiny select for large boards
	self.large_select = false -- difficulty selector
	self.visible_select = true -- false when off the board on higher difficulty
	self.covered_select = false -- true when touching advanced anims panel
	self.hide_select = false -- for hiding select while touching other objects
	self.tile_lit = false
	self.m_row_prev = 0
	self.m_col_prev = 0
	self.current_orb = nil
	self.board_size = 16
	self.mini_offS = 0
	self.more_anims = false
	go.set("/diff-selected", "position", vmath.vector3((19 + l_data.diff)*8+4, 8*8+4, 0.7))
	go.set("/zoom#board", "tile_source", self.tilesources[self.theme])
	go.set("/zoom#board-mini", "tile_source", self.tilesources_mini[self.theme])
	go.set("/diff-selected-temp", "position.z", -0.7)
	-- resource.set_texture(path, table, buffer)
end



-- __    __    ____     _____
--|   \/   |  /  __\   /  ___|
--| |\__/| |  \__  \  |  |_  \
--|_|    |_|  \____/   \_____/

function on_message(self, message_id, message, sender)
	if message_id == hash("setup") then
		print("setup")
		
		self.board = {}
		set_props(self)
		self.row_offS = math.floor((self.board_size-self.row_size)/2)
		self.col_offS = math.floor((self.board_size-self.col_size)/2)
		if self.row_size%2 == 1 then
			self.row_odd_offS = 1
			print("odd row")
		else
			self.row_odd_offS = 0
			print("no odd row offset")
		end
		if self.col_size%2 == 1 then
			self.col_odd_offS = 1
			print("odd col")
		else
			self.col_odd_offS = 0
			print("no odd col offset")
			
		end
		self.playing = true
		self.wrong_flags = nil
		self.to_flip = {}
		self.timer = nil
		self.anim_skip = false
		self.resettable = true

		-- clearing border for a larger border
		if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", 2+self.col_offS, self.board_size/2+1) ~= 11 or tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", self.board_size/2+1, 2+self.row_offS) ~= 11 then 
			for r = 1, self.board_size do
				for c = 1, self.board_size do
					if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS) ~= 11  then
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS, 11)
					end
				end
			end
		end
		
		-- setting border
		if self.row_offS > 0 or self.col_offS > 0 or self.row_odd_offS > 0 or self.col_odd_offS > 0 then
			for r = 1, self.board_size do
				for c = 1, self.board_size do
					if (r <= self.row_offS or r > self.board_size-self.row_offS-self.row_odd_offS) or (c <= self.col_offS or c > self.board_size-self.col_offS-self.col_odd_offS) then
						if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS) ~= 14 then
							tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS, 14)
						end
					end
				end
			end
		end

		if self.row_size > 16 or self.col_size > 16 then
			for r = 1, 16 do
				for c = 1, 16 do
					tilemap.set_tile("/zoom#board", "layer1", c+1, r+1, 20)
				end
			end
		end
		
		msg.post(".", "acquire_input_focus")
		math.randomseed(socket.gettime())
	elseif message_id == hash("reset") then --checkpoint
		if self.resettable then
			msg.post("/gui#minefinder", "purge_instances")
			self.mine_locs = nil
			self.mine_i = nil
			self.timer = 0
			self.playing = false
			msg.post("/gui#minefinder", "reset", {mines = self.num_mines})
			self.resettable = false
			for r = self.row_size+self.row_offS, 1+self.row_offS, -1 do
				for c = 1+self.col_offS, self.col_size+self.col_offS do
					if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS, r+1+self.mini_offS) ~= 11 or self.anims["flip_bg"] then
						table.insert(self.to_flip, {r+self.mini_offS, c+self.mini_offS})
					end
				end
			end
			if #self.to_flip < 1 then
				msg.post(".", "setup")
			end
		elseif #self.to_flip > 0 then
			self.anim_skip = true
		end
	elseif message_id == hash("set_anims") then
		if message.anims == false then
			msg.post("/gui#minefinder", "purge_instances")
			if self.resettable == false and #self.to_flip == 0 then
				msg.post(".", "setup")
			end
		end
		if message.anims == true or message.anims == false then
			for i = 1, 8 do
				self.anims[self.anim_vars[i]] = message.anims
			end
		end
	elseif message_id == hash("update_anims") then
		-- WIP - purge specific instances
		self.anims[self.anim_vars[message.index]] = message.setting
	elseif message_id == hash("remove_orb") then
		self.current_orb = "done"
	elseif message_id == hash("set_theme") then
		self.theme = message.theme
		go.set("/zoom#board", "tile_source", self.tilesources[self.theme])
		go.set("/zoom#board-mini", "tile_source", self.tilesources_mini[self.theme])
		local tilenum
		if self.theme == "light" then
			tilenum = 16
		else
			tilenum = 18
		end
		msg.post(".", "flash", {tile = tilenum})
	elseif message_id == hash("flash") then -- WIP
		self.playing = false
		
		for r = 1, self.row_size do
			for c = 1, self.col_size do
				tilemap.set_tile("/zoom#flash"..self.mini_txt, "layer1", c+1+self.col_offS+self.mini_offS, r+1+self.row_offS+self.mini_offS, message.tile)
			end
		end

		self.flash_timer = 0.1
	elseif message_id == hash("replace_board") then -- WIP
		for r = 1, self.row_size do 
			for c = 1, self.col_size do
				tilemap.set_tile("/zoom#flash"..self.mini_txt, "layer1", c+1+self.col_offS+self.mini_offS, r+1+self.row_offS+self.mini_offS, 20)
			end
		end
		self.playing = true
		self.board_tiles = nil
		self.flash_timer = nil
	elseif message_id == hash("more_anims") then
		self.more_anims = message.shown
	elseif message_id == hash("set_diff") then
		l_data.diff = l_data.diff_temp
		l_data.diff_temp = nil
		go.set("/diff-selected", "position", vmath.vector3((19 + l_data.diff)*8+4, 8*8+4, 0.7))
		go.set("/diff-selected-temp", "position.z", -0.7)
	elseif message_id == hash("hide_select") then 
		if message.hid then
			sprite.set_constant("/selection", "tint", vmath.vector4(1, 1, 1, 0))
		else
			sprite.set_constant("/selection", "tint", vmath.vector4(1, 1, 1, 1))
			go.set("/selection", "position.z", 0.8)
		end
		self.hide_select = message.hid
		self.select_update = true
	end
end


-- _    __    _    ___     __ __    _____
--| |  |   \ | |  |  _ \  |  |  |  |_   _|
--| |  | |\ \| |  |  __/  |  |  |    | |
--|_|  |_| \___|  |_|      \___/     |_|

function on_input(self, action_id, action)
	local zoom = math.min(self.screen_size.x / self.screen_ratio.x, self.screen_size.y / self.screen_ratio.y)
	local projected_width = self.screen_size.x / zoom
	local projected_height = self.screen_size.y / zoom
	local xoffset = -(projected_width - self.screen_ratio.x) / 2
	local yoffset = -(projected_height - self.screen_ratio.y) / 2
	local mouse_x = (action.x / self.screen_ratio.x) * projected_width + xoffset
	local mouse_y = (action.y / self.screen_ratio.y) * projected_height + yoffset
	
	if (action_id == hash("touch") or action_id == hash("select")) and action.pressed and self.playing then
		-- local moveRow = math.floor(mouse_y/48) --gives the mouse tile for strictly 8x8 tiles
		-- local moveCol = math.floor(mouse_x/48)
		local moveRow_t = math.floor(mouse_y/(6*self.tile_size)) --gives the mouse tile for varying game tiles
		local moveCol_t = math.floor(mouse_x/(6*self.tile_size))
		if moveRow_t < self.row_size+1+self.mini_offS+self.row_offS and moveCol_t < self.col_size+1+self.mini_offS+self.col_offS and moveRow_t > self.row_offS+self.mini_offS and moveCol_t > self.col_offS+self.mini_offS then
			self.tile_clicked = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1)
			self.row_clicked = moveRow_t
			self.col_clicked = moveCol_t
			tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, 16)
		-- 	print(moveRow_t+1, moveCol_t+1)
		end
	end
	
	if self.tile_clicked and (action_id == hash("touch") or action_id == hash("select")) and action.released and self.playing then
		-- local moveRow = math.floor(mouse_y/48)
		-- local moveCol = math.floor(mouse_x/48)
		local moveRow_t = math.floor(mouse_y/(6*self.tile_size))
		local moveCol_t = math.floor(mouse_x/(6*self.tile_size))
		-- print(11-moveRow .. ", " .. moveCol)

		if moveRow_t < self.row_size+1+self.mini_offS+self.row_offS and moveCol_t < self.col_size+1+self.mini_offS+self.col_offS and moveRow_t > self.row_offS+self.mini_offS and moveCol_t > self.col_offS+self.mini_offS then
			if not self.board[1] then --first move
				self.board = {}
				for i = 1, self.row_size do
					table.insert(self.board, {})
				end

				for r = 1, self.row_size do -- setting the board up
					for c = 1, self.col_size do
						self.board[r][c] = 0
					end
				end

				self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS] = 14

				local count = 1
				while count <= self.num_mines do -- adding mines
					local randRow = math.random(1, self.row_size)
					local randCol = math.random(1, self.col_size)
					if mines_around(self, randRow, randCol) <= spaces_around(self, randRow, randCol)+1 and self.board[randRow][randCol] ~= 12 then
						-- print(randRow .. ", " .. randCol)
						self.board[randRow][randCol] = 12
						count = count + 1
					end
					-- print(mines_around(self, randRow, randCol) .. ", " .. spaces_around(self, randRow, randCol))
				end

				self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS] = 1

				for r = 1, self.row_size do
					for c = 1, self.col_size do
						if self.board[r][c] == 0 then
							self.board[r][c] = mines_around(self, r, c) + 1
						end
					end
				end

				show_block(self, moveRow_t, moveCol_t)
				self.flashing = true
				self.timer = 0.1
				msg.post("/gui#minefinder", "set_ticking", {ticking = true})
				
			else --NOT first move
				if self.tile_clicked == 13 then -- remove flag
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, 11)
					if self.anims["flag_remove"] then
						local props = {type = 2, theme_id = theme_to_id(self.theme)}
						local id = factory.create("#flag-factory", vmath.vector3(moveCol_t*6*self.tile_size+self.tile_size*3, moveRow_t*6*self.tile_size+self.tile_size*3, 0.5), nil, props)
						msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
					end
				elseif action_id == hash("select") and self.tile_clicked == 11 then -- place flag
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, 13)
					if self.anims["flag_place"] then
						local props = {type = 1-self.mini_offS, theme_id = theme_to_id(self.theme)}
						local id = factory.create("#flag-factory", vmath.vector3(moveCol_t*(6*self.tile_size)+3*self.tile_size, moveRow_t*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
						msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
					end
				elseif self.tile_clicked > 10 then -- reveal block
					if self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS] == 1 then -- flip tile
						show_block(self, moveRow_t, moveCol_t)
						self.flashing = true
						self.timer = 0.1
						
					elseif self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS] == 12 then -- flip mine
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
						msg.post("/gui#minefinder", "set_ticking", {ticking = false})
						print("you lose!")
						self.playing = false
						if self.anims["explosion"] then
							local props = {wick = true, mini = self.mini_offS}
							local id = factory.create("#explosion-factory", vmath.vector3(moveCol_t*(6*self.tile_size)+3*self.tile_size, moveRow_t*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
							msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
						end
						
						self.mine_locs = {}
						for r = 1, self.row_size do
							for c = 1, self.col_size do
								if self.board[r][c] == 12 and not (r == moveRow_t-self.row_offS-self.mini_offS and c == moveCol_t-self.col_offS-self.mini_offS) then
									if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.col_offS+self.mini_offS, r+1+self.row_offS+self.mini_offS) == 13 then
										table.insert(self.mine_locs, {r+self.row_offS+self.mini_offS, c+self.col_offS+self.mini_offS, true})
									else
										table.insert(self.mine_locs, {r+self.row_offS+self.mini_offS, c+self.col_offS+self.mini_offS, false})
									end
								end
							end
						end
						shuffle(self.mine_locs)

						self.timer = 3
						self.mine_i = 1
					else -- digging a tile
						tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
						
					end
				else
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", moveCol_t+1, moveRow_t+1, self.board[moveRow_t-self.row_offS-self.mini_offS][moveCol_t-self.col_offS-self.mini_offS])
				end
				local flag_count = 0
				local won_game = true 
				local tile = nil
				for r = 1, self.row_size do
					for c = 1, self.col_size do
						tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.col_offS+self.mini_offS, r+1+self.row_offS+self.mini_offS)
						if tile == 13 then
							flag_count = flag_count + 1
						end
						if won_game and tile > 9 and tile ~= 16 and self.board[r][c] < 10 then
							won_game = false
						end
					end
				end
				
				msg.post("/gui#minefinder", "set_flags", {num = self.num_mines-flag_count})

				if won_game then
					print("you win!")
					self.playing = false
					msg.post("/gui#minefinder", "set_ticking", {ticking = false})
					msg.post("/gui#minefinder", "set_hs")
					for r = self.row_offS, self.row_size+self.row_offS do
						for c = self.col_offS, self.col_size+self.col_offS do
							if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1, r+1) == 11 then
								tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1, r+1, 13)
								if self.anims["flag_place"] then
									local props = {type = 1-self.mini_offS, theme_id = theme_to_id(self.theme)}
									local id = factory.create("#flag-factory", vmath.vector3(c*(6*self.tile_size)+3*self.tile_size, r*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
									msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
								end
							end
						end
					end
				end
			end
		end
		self.tile_clicked = nil
		self.row_clicked = nil
		self.col_clicked = nil
	end

	local moveRow = math.floor(mouse_y/(48))
	local moveCol = math.floor(mouse_x/(48))
	local moveRow_t = math.floor(mouse_y/(6*self.tile_size))
	local moveCol_t = math.floor(mouse_x/(6*self.tile_size))
	if self.row_clicked and (self.row_clicked ~= moveRow_t or self.col_clicked ~= moveCol_t) then --reset tile when mouse moved off
		tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.col_clicked+1, self.row_clicked+1, self.tile_clicked)
		self.tile_clicked = nil
		self.row_clicked = nil
		self.col_clicked = nil
	end

	
	if not self.more_anims and moveCol > 19 and moveCol < 26 and math.floor(moveRow) == 8 then --change difficulty
		if not self.large_select then
			sprite.play_flipbook("/selection", "selection-large")
			self.large_select = true
		end
		if moveCol == 25 then
			if self.current_orb == nil and self.anims["ui"] then
				local id = factory.create("#orb-factory", vmath.vector3(25*48+24, 8*48+24, 0.9))
				self.current_orb = msg.url(nil, id, nil)
				msg.post("/gui#minefinder", "add_url", {hash = self.current_orb})
			end
		elseif self.current_orb ~= nil then
			if self.current_orb ~= "done" then
				msg.post(self.current_orb, "erase")
			end
			self.current_orb = nil
		end
		if action_id == hash("touch") and action.pressed and not self.tile_lit then
			go.set("/brighten", "position", vmath.vector3(moveCol*8+4, moveRow*8+4, 1))
			self.tile_lit = true
		elseif action_id == hash("touch") and action.released and self.tile_lit then
			if moveCol - 19 ~= l_data.diff then
				l_data.diff_temp = moveCol - 19
				go.set("/diff-selected-temp", "position", vmath.vector3((19 + l_data.diff_temp)*8+4, 8*8+4, 0.7))
				go.set("/brighten", "position", vmath.vector3(20, 12, -0.5))
				msg.post("/gui#minefinder", "switch_hs")
				self.tile_lit = false
			else
				l_data.diff_temp = nil
				go.set("/diff-selected-temp", "position.z", -0.7)
				go.set("/brighten", "position", vmath.vector3(20, 12, -0.5))
				msg.post("/gui#minefinder", "switch_hs")
				self.tile_lit = false
			end
		elseif moveCol*8+4 ~= self.m_col_prev and self.tile_lit then
			go.set("/brighten", "position", vmath.vector3(20, 12, -0.5))
			self.tile_lit = false
		end
	else
		if self.current_orb ~= nil then
			if self.current_orb ~= "done" then
				msg.post(self.current_orb, "erase")
			end
			self.current_orb = nil
		end
		if self.tile_lit then
			go.set("/brighten", "position", vmath.vector3(20, 12, -0.5))
			self.tile_lit = false
		end
		if moveCol > 17 and (self.hard_select or self.large_select or self.mini_select) then
			sprite.play_flipbook("/selection", "selection-2")
			self.hard_select = false
			self.large_select = false
			self.tile_lit = false
			self.mini_select = false
		elseif self.tile_size == 4 and not self.mini_select and moveCol < 18 then
			sprite.play_flipbook("/selection", "selection-mini")
			self.mini_select = true
			self.hard_select = false
			self.large_select = false
			self.tile_lit = false
		elseif moveCol < 18 and (not self.hard_select or self.large_select) and self.tile_size == 8 then
			sprite.play_flipbook("/selection", "selection")
			self.hard_select = true
			self.large_select = false
			self.tile_lit = false
			self.mini_select = false
		end
	end

	local m_row
	local m_col
	
	if moveCol < 17 and self.tile_size ~= 8 then --position x/y of select
		m_row = moveRow_t*self.tile_size+self.tile_size/2
		m_col = moveCol_t*self.tile_size+self.tile_size/2
	else
		m_row = moveRow*8+4
		m_col = moveCol*8+4
	end

	local change_cover_var = true
	if self.more_anims and not self.covered_select and (mouse_y > 168 and mouse_y < 552) and (mouse_x > 888 and mouse_x < 1320) then --invisible select on more anims
		self.covered_select = true
	elseif self.covered_select and not ((mouse_y > 168 and mouse_y < 552) and (mouse_x > 888 and mouse_x < 1320)) then
		self.covered_select = false
	else
		change_cover_var = false
	end


	if self.covered_select or self.hide_select then
		go.set("/selection", "position", vmath.vector3(m_col, m_row, -0.8))
	elseif self.m_row_prev ~= m_row or self.m_col_prev ~= m_col or change_cover_var or self.select_update then
		if moveRow < 0 or moveRow > 17 or moveCol < 0 or moveCol > 28 then
			if self.select_update then
				self.select_update = nil
			end
			if self.visible_select then
				sprite.set_constant("/selection", "tint", vmath.vector4(1, 1, 1, 0))
				self.visible_select = false
			end
		elseif not self.visible_select then
			sprite.set_constant("/selection", "tint", vmath.vector4(1, 1, 1, 1))
			self.visible_select = true
		end
		
		local z_pos = 0.8
		if self.mini_offS == 1 and self.mini_select and (moveRow_t >= self.row_size+1+self.mini_offS+self.row_offS or moveCol_t >= self.col_size+1+self.mini_offS+self.col_offS or moveRow_t <= self.row_offS+self.mini_offS or moveCol_t <= self.col_offS+self.mini_offS) then
			z_pos = -0.8
		end
		-- go.set("/diff-selected", "position", vmath.vector3(moveCol*8+4, moveRow*8+4, 0.8))
		go.set("/selection", "position", vmath.vector3(m_col, m_row, z_pos))
	end

	self.m_row_prev = m_row
	self.m_col_prev = m_col

	if (action_id == hash("debug")) and action.pressed then
		print(self.timer)
	end
	
end



-- __ __    ___     ___       ___     _____    _____
--|  |  |  |  _ \  |    \    /   \   |_   _|  |  ___|
--|  |  |  |  __/  |  |  |  | /_\ |    | |    |  __|
-- \___/   |_|     |____/   |_| |_|    |_|    |_____|

function update(self, dt) --checkpoint
	-- print(self.timer, self.board[1], #self.to_flip)
	if self.timer and (self.board[1] or #self.to_flip > 0 or self.board_tiles) then
		while (self.timer <= 0 or (self.anims["timer"] == false and not self.flashing) or self.anim_skip == true) and (self.flashing or (self.mine_locs and self.mine_i <= #self.mine_locs) or #self.to_flip > 0) do
			-- print("acting")
			-- tilemap.set_tile("/zoom#board", "layer1", moveCol+1, moveRow+1, self.board[moveRow][moveCol])
			if self.flashing then
				for r = 1, self.row_size do
					for c = 1, self.col_size do
						if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS+self.col_offS, r+1+self.mini_offS+self.row_offS) == 16 then
							tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", c+1+self.mini_offS+self.col_offS, r+1+self.mini_offS+self.row_offS, self.board[r][c])
						end
					end
				end
				self.flashing = false
			elseif #self.to_flip > 0 then
				if self.anims["tileflip"] then
					if #self.to_flip == 1 then
						local props = {final = 1, tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1), mini = self.mini_offS, tile_size = self.tile_size, theme_id = theme_to_id(self.theme)}
						local id = factory.create("#flip-factory", vmath.vector3(self.to_flip[1][2]*(6*self.tile_size)+3*self.tile_size, self.to_flip[1][1]*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
						msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
					else
						local props = {final = 0, tile = tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1), mini = self.mini_offS, tile_size = self.tile_size, theme_id = theme_to_id(self.theme)}
						local id = factory.create("#flip-factory", vmath.vector3(self.to_flip[1][2]*(6*self.tile_size)+3*self.tile_size, self.to_flip[1][1]*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
						msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
					end
				else
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", self.to_flip[1][2]+1, self.to_flip[1][1]+1, 11)
				end
				if self.anims["faster_flip"] then
					self.timer = 0.01
				else
					self.timer = 0.02
				end
				if #self.to_flip == 1 and self.anims["tileflip"] == false then
					msg.post(".", "setup")
				end
				table.remove(self.to_flip, 1)
			else
				local mineRow = self.mine_locs[self.mine_i][1]
				local mineCol = self.mine_locs[self.mine_i][2]
				if self.mine_locs[self.mine_i][3] then
					if self.anims["flag_correct"] then
						local props = {type = 3, theme_id = theme_to_id(self.theme)}
						local id = factory.create("#flag-factory", vmath.vector3(mineCol*(6*self.tile_size)+3*self.tile_size, mineRow*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
						msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
					end
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", mineCol+1, mineRow+1, 17)
				else
					tilemap.set_tile("/zoom#board"..self.mini_txt, "layer1", mineCol+1, mineRow+1, self.board[mineRow-self.row_offS-self.mini_offS][mineCol-self.col_offS-self.mini_offS])
					if self.anims["explosion"] then
						local props = {wick = false, mini = self.mini_offS}
						local id = factory.create("#explosion-factory", vmath.vector3(mineCol*(6*self.tile_size)+3*self.tile_size, mineRow*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
						msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
					end
				end

				self.timer = 1/self.mine_i
				
				if self.mine_i == #self.mine_locs then
					self.wrong_flags = {}
					self.mine_i = 1000
					self.flag_i = 1	
					for r = self.row_size+self.row_offS+self.mini_offS, 1+self.row_offS+self.mini_offS, -1 do
						for c = 1+self.col_offS, self.col_size+self.col_offS do
							if tilemap.get_tile("/zoom#board"..self.mini_txt, "layer1", c+1, r+1) == 13 then
								table.insert(self.wrong_flags, {r, c})
							end
						end
					end

					-- shuffle(self.wrong_flags) --makes wrong flags show in random order
					self.timer = 2.5
				end
				self.mine_i = self.mine_i + 1
			end
		end
		while (self.timer <= 0 or self.anims["timer"] == false or self.anim_skip == true) and self.wrong_flags and self.flag_i <= #self.wrong_flags do
			local flagRow = self.wrong_flags[self.flag_i][1]
			local flagCol = self.wrong_flags[self.flag_i][2]
			if self.anims["flag_incorrect"] then
				local props = {type = 4 + self.mini_offS, theme_id = theme_to_id(self.theme)}
				local id = factory.create("#flag-factory", vmath.vector3(flagCol*(6*self.tile_size)+3*self.tile_size, flagRow*(6*self.tile_size)+3*self.tile_size, 0.5), nil, props)
				msg.post("/gui#minefinder", "add_url", {hash = msg.url(nil, id, nil)})
			end
			self.timer = 1
			self.flag_i = self.flag_i + 1
		end
		if (self.board[1] or #self.to_flip > 0 or self.board_tiles) and self.flashing or (self.mine_locs and self.mine_i <= #self.mine_locs) or (self.wrong_flags and self.flag_i <= #self.wrong_flags) or #self.to_flip > 0 or self.board_tiles then
			self.timer = self.timer - dt
		else 
			self.timer = nil
		end
	end

	if self.flash_timer then
		if self.flash_timer <= 0 then
			msg.post(".", "replace_board")
		else
			self.flash_timer = self.flash_timer - dt
		end
	end
end
